<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/VEN/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/VEN/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Better late than never.">
<meta property="og:type" content="website">
<meta property="og:title" content="向万鹏的独立博客">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="向万鹏的独立博客">
<meta property="og:description" content="Better late than never.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="向万鹏的独立博客">
<meta name="twitter:description" content="Better late than never.">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/5/"/>

  <title> 向万鹏的独立博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">向万鹏的独立博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/19/Java中异常的限制/" itemprop="url">
                  Java中异常的限制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-19T08:58:23+08:00" content="2016-09-19">
              2016-09-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java基础/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/19/Java中异常的限制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/19/Java中异常的限制/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　在Java中，发现错误的最理想时机是在编译阶段，即运行程序之前。但是，在编译期间，并不能保证所有的错误都被发现，余下的问题必须在运行期间解决。这就需要错误源能通过某种方式，把适当的信息传递给某个接收者——该接收者将知道如何正确处理这个问题。异常处理是Java中唯一正式的错误报告机制，并且通过编译器强制执行。本文略过了异常处理流程等基本知识，直接讨论Java中异常的限制。<br>　　异常的限制，这是指：<strong>当覆盖方法的时候，只能抛出在基类方法的异常说明里列出的那些异常。</strong>这样的限制可以保证，当派生类对象向上转型为基类对象时，它的某个方法不会抛出基类方法未声明的异常。下面的例1演示了这种限制：<br>　　<br>例1：</p>
<pre><code>class BaseballException extends Exception {}
class Foul extends BaseballException {}
class Strike extends BaseballException {}

abstract class Inning {
  public Inning() throws BaseballException {}
  public void event() throws BaseballException {
  }
  public abstract void atBat() throws Strike, Foul;
  public void walk() {} 
}

class StormException extends Exception {}
class RainedOut extends StormException {}
class PopFoul extends Foul {}

interface Storm {
  public void event() throws RainedOut;
  public void rainHard() throws RainedOut;
}

public class StormyInning extends Inning implements Storm {
  public StormyInning()
    throws RainedOut, BaseballException {}
  public StormyInning(String s)
    throws Foul, BaseballException {}
  //! void walk() throws PopFoul {} //Compile error
  public void rainHard() throws RainedOut {}
  public void event() {}
  public void atBat() throws PopFoul {}
  public static void main(String[] args) {
    try {
      StormyInning si = new StormyInning();
      si.atBat();
    } catch(PopFoul e) {
      System.out.println(&quot;Pop foul&quot;);
    } catch(RainedOut e) {
      System.out.println(&quot;Rained out&quot;);
    } catch(BaseballException e) {
      System.out.println(&quot;Generic baseball exception&quot;);
    }
    try {
      Inning i = new StormyInning();
      i.atBat();
    } catch(Strike e) {
      System.out.println(&quot;Strike&quot;);
    } catch(Foul e) {
      System.out.println(&quot;Foul&quot;);
    } catch(RainedOut e) {
      System.out.println(&quot;Rained out&quot;);
    } catch(BaseballException e) {
      System.out.println(&quot;Generic baseball exception&quot;);
    }
  }
}
</code></pre><p>　　我们可以看到，Inning类中的构造器和event()函数都声明抛出了异常，但实际上在方法体中并没有抛出，这是可行并且合理的，因为采用这种方式可以强制用户去捕获可能在覆盖后的event()方法中抛出的异常，这同样适用于抽象方法，如atBat()。<br>　　我们注意观察一下接口Storm，它定义了一个和Inning类中event()方法同名的一个方法，而且参数列表也相同，并且该方法抛出了一个在Inning类中event()方法没有抛出的异常RainOut，那么如果StormyInning既继承了Inning类，又实现了Storm接口，这两个event()方法是不能互相改变彼此的异常接口的。换句话说，StormyInning中的event()方法不能声明抛出Inning类和Storm接口中event()方法声明的任何异常。<br>　　但是，这种异常限制却对构造器不起作用。你可以发现，StormyInning类的构造器中声明抛出了Inning类构造器没有抛出的异常。但是，由于在创建子类对象时会自动调用基类的构造器，所以子类的构造器的异常声明必须包含基类构造器的异常声明。同时我们可以证明，派生类的构造器不能捕获它的基类构造器所抛出的异常，因为在派生类构造器中，super()函数的调用必须放在第一行，这便不能将try-catch语句插入。<br>　　在StormyInning中，walk()函数不能通过编译，这是因为它声明抛出了在Inning.walk()中没有声明抛出的异常。如果编译器允许这么做的话，那么我们在调用Inning.walk()的时候不用做异常处理，但是在我们执行向上转型Inning inning = new StormyInning()后，再调用inning.walk()时，这个方法便可能抛出异常，但我们却并没有捕获。<br>　　覆盖后的event()方法并没有声明抛出任何异常，这说明派生类中的方法可以不声明抛出异常。这样做是可行的，因为这并不会出现上一段所描述的情况。类似的情况出现在StormyInning.atBat()上，它抛出了异常PopFoul，而Inning.atBat()抛出了异常Foul，这么做可行是因为，PopFoul是Foul的子类，能捕获Foul异常的异常处理程序肯定也能捕获到PopFoul异常。<br>　　最后我们注意到main()，如果我们使用的是StormyInning对象的话，那么编译器只会强制要求你捕获StormyInning类所抛出的异常。但是如果我们使用的是通过向上转型得到的基类Inning对象时，那么编译器就会强制你捕获基类Inning所抛出的异常。所有这些限制都是为了能产生更为强壮的异常处理代码。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/12/Java中构造器内部的多态方法的行为/" itemprop="url">
                  Java中构造器内部的多态方法的行为
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-12T15:00:59+08:00" content="2016-09-12">
              2016-09-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java基础/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/12/Java中构造器内部的多态方法的行为/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/12/Java中构造器内部的多态方法的行为/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　这篇文章主要讨论的是，若在一个构造器中调用正在构造的对象的某个动态绑定的方法时会出现的情况。在此之前，我们需要知道构造器是如何在复杂的层次结构中运作的，尽管构造方法并不具有多态性，因为它们实际上是static方法，只不过是隐式声明的static。</p>
<h2 id="复杂层次结构中构造器的调用顺序"><a href="#复杂层次结构中构造器的调用顺序" class="headerlink" title="复杂层次结构中构造器的调用顺序"></a><strong>复杂层次结构中构造器的调用顺序</strong></h2><p> 　　基类的构造器总是在导出类的构造过程中被调用，而且按照继承层次逐渐向上链接，以使每个基类的构造器都能得到调用。这样做是因为，在Java类中，我们通常将字段设置为private类型，也就是说，在子类中通常无法直接访问基类的字段，那么只有通过调用基类的构造器才能对基类对象的元素进行初始化，那么就必须保证所有的构造器都得到调用，这样才能正确地构造完整的对象。下面的例1展示了包含有组合与继承关系的各类中构造器的调用顺序：<br> 　　<br>例1：</p>
<pre><code>class Meal {
  Meal() { System.out.println(&quot;Meal()&quot;); }
}

class Bread {
  Bread() { System.out.println(&quot;Bread()&quot;); }
}

class Cheese {
  Cheese() { System.out.println(&quot;Cheese()&quot;); }
}

class Lettuce {
  Lettuce() { System.out.println(&quot;Lettuce()&quot;); }
}

class Lunch extends Meal {
  Lunch() { System.out.println(&quot;Lunch()&quot;); }
}

class PortableLunch extends Lunch {
  PortableLunch() { System.out.println(&quot;PortableLunch()&quot;);}
}

public class Sandwich extends PortableLunch {
  private Bread b = new Bread();
  private Cheese c = new Cheese();
  private Lettuce l = new Lettuce();
  public Sandwich() { System.out.println(&quot;Sandwich()&quot;); }
  public static void main(String[] args) {
    new Sandwich();
  }
}
</code></pre><p>　　例1反映了关于Meal、Lunch和Sandwich之间三层继承关系（不包含Object类），以及Bread、Cheese和Lettuce与Sandwich的组合关系。在main函数中创建一个Sandwich对象后，我们就可以看到输出结果：<br>　　<br><img src="http://static.zybuluo.com/xiangwanpeng/0fpf4b82u3pemicexb80xifs/sandwich1.png" alt="sandwich1.png-14.5kB"></p>
<p>　　这说明在复杂的层次结构中构造器的调用遵从的顺序为：<br>　　<br>　　<strong>1、调用基类构造器。这个步骤会不断地反复递归下去，首先是构造这种层次结构的根，然后是下一层导出类，等等，直到最低层的导出类；<br>　　2、按声明的顺序调用成员的初始化方法；<br>　　3、调用导出类构造器的主体。</strong>
　　
　　</p>
<h2 id="构造器内部的多态方法的行为"><a href="#构造器内部的多态方法的行为" class="headerlink" title="构造器内部的多态方法的行为"></a><strong>构造器内部的多态方法的行为</strong></h2><p> 　　那么，现在我们回到文章开头提到的问题，若在一个构造器中调用正在构造的对象的某个动态绑定的方法，会出现什么情况呢？我们知道，动态绑定（或后期绑定）的方法的调用是在运行时才决定的，因为对象在程序运行之前无从得知它自己到底是基类的对象，还是某个导出类的对象。如果在基类的构造器内部调用某个动态绑定方法，该方法是被导出类覆盖的，那么这便可能产生难以预料的后果，因为该导出类的对象还未被完全构造，但它的方法却被调用了。我们可以通过例2看到问题所在：</p>
<p>例2：</p>
<pre><code>class Glyph {
   void draw() { System.out.println(&quot;Glyph.draw()&quot;); }
   Glyph() {
     System.out.println(&quot;Glyph() before draw()&quot;);
     draw();
     System.out.println(&quot;Glyph() after draw()&quot;);
   }
 }    

 class RoundGlyph extends Glyph {
   private int radius = 1;
   RoundGlyph(int r) {
     radius = r;
     System.out.println(&quot;RoundGlyph.RoundGlyph(), radius = &quot; + radius);
   }
   void draw() {
     System.out.println(&quot;RoundGlyph.draw(), radius = &quot; + radius);
   }
 }    

 public class PolyConstructors {
   public static void main(String[] args) {
     new RoundGlyph(5);
   }
 }
</code></pre><p>运行结果：</p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/c3z3dqr01e9mtkt486m7gk9d/sandwich2.png" alt="sandwich2.png-14.4kB"></p>
<p>　　在运行结果中，我们看到，基类Glyph的构造器中调用了被子类RoundGlyph覆盖的draw()方法，并且输出了radius=0，这显然是一个错误，因为这个“0”是在其他任何事物发生之前，系统分配给对象的存储空间的初始值——二进制的零，而非我们想要设定的初始值“1”。这是因为，我们在创建子类（RoundGlyph）对象时会先调用基类（Glyph）的构造器构造基类对象，而在基类的构造器中却调用了被子类覆盖的动态绑定的方法（draw()），而这个方法所操纵的可能是子类中的还未进行初始化的成员（radius），这便会招致灾难，尽管编译器并没有报错。<br>　　因此，在编写构造器中有一条有效的准则：“<strong>用尽可能简单的方法使对象进入正常状态；如果可以的话，避免调用其他方法</strong>”。在构造器中，唯一能够安全调用的是基类中的final方法（包括private方法），因为这些方法不能被子类覆盖，也就不会出现上述的问题。</p>
<p>　　<br>参考书籍：《Java编程思想》</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/11/static方法能否被重写/" itemprop="url">
                  static方法能否被重写
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-11T14:53:36+08:00" content="2016-09-11">
              2016-09-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java基础/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/11/static方法能否被重写/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/11/static方法能否被重写/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的<strong>重写</strong>(Override)。方法重写又称方法覆盖。<br>　　在《Java编程思想》中提及到：</p>
<blockquote>
<p>　　“覆盖”只有在某方法是基类的接口的一部分时才会出现。即，必须能将一个对象向上转型为它的基本类型并调用相同的方法。</p>
</blockquote>
<p>　　那么，我们便可以据此来对static方法能否被重写的问题进行验证：<br>　　<br>例1：
　　</p>
<pre><code>class StaticSuper{
    public static String staticGet(){
        return &quot;Base staticGet()&quot;;
    }
    public String dynamicGet(){
        return &quot;Base dynamicGet()&quot;;
    }
}

class StaticSub extends StaticSuper{
    public static String staticGet(){
        return &quot;Derived staticGet()&quot;;
    }
    public String dynamicGet(){
        return &quot;Derived dynamicGet()&quot;;
    }
}

public class StaticPolyMorphism {
    public static void main(String[] args) {
        StaticSuper sup = new StaticSub();
        System.out.println(sup.staticGet());
        System.out.println(sup.dynamicGet());
    }
}
</code></pre><p>　　在例1中，如果基类StaticSuper中的static方法staticGet()在子类StaticSub中被重写了，那么sup.staticGet()返回的结果应该是“Derived staticGet()”，实际上结果是如何呢？运行程序后，我们看到输出是：<br>　　<br>　　Base staticGet()<br>　　Derived dynamicGet()　<br>　　<br>　　这说明，非静态方法dynamicGet()的确在子类中被重写了，而静态方法staticGet()却没有。对于这一点，我们也可以通过在子类方法上添加@Overide注解进行验证：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/infnaam652cnnrrwrplxzmdl/override.png" alt="override.png-18.6kB"><br>　　<br>　　如图所示，在子类中的静态方法staticGet()上添加@Override注解会导致编译报错：The method staticGet() of type StaticSub must override or implement a supertype method（StaticSub类的staticGet()方法必须覆盖或者实现一个父型的方法），而非静态方法dynamicGet()则无此报错信息，这也就印证了我们上面的推论。其实，<strong>在Java中，如果父类中含有一个静态方法，且在子类中也含有一个返回类型、方法名、参数列表均与之相同的静态方法，那么该子类实际上只是将父类中的该同名方法进行了隐藏，而非重写。换句话说，父类和子类中含有的其实是两个没有关系的方法，它们的行为也并不具有多态性。</strong>正如同《Java编程思想》中所说：“一旦你了解了多态机制，可能就会认为所有事物都可以多态地发生。然而，只有普通方法的调用可以是多态的。”这也很好地理解了，为什么在Java中，static方法和final方法（private方法属于final方法）是前期绑定，而其他所有的方法都是后期绑定了。</p>
<p>　　</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/06/finalize()方法的使用/" itemprop="url">
                  finalize()方法的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-06T22:08:46+08:00" content="2016-09-06">
              2016-09-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java基础/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/06/finalize()方法的使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/06/finalize()方法的使用/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　Java定义了finalize()方法，用于在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。在《Java编程思想》一书中，有这样一段话：</p>
<blockquote>
<p>　　Java有垃圾回收器负责回收无用对象占据的内存资源。但也有特殊情况：假定你的对象（并非使用new）获得了一块“特殊”的内存区域，由于<strong>垃圾回收器只知道释放那些经由new分配的内存</strong>，所有它不知道如何释放该对象的这块“特殊”内存。为了应对这种情况，Java允许在类中定义一个名为finalize()的方法。它的工作原理“假定”是这样的：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。所以要是你打算用finalize()，就能在垃圾回收时刻做一些重要的清理工作。</p>
</blockquote>
<h2 id="和析构函数的区别"><a href="#和析构函数的区别" class="headerlink" title="- 和析构函数的区别"></a>- 和析构函数的区别</h2><p>　　finalize()方法与C++中的析构函数有几分相似之处，但是二者又不完全等同。在C++中，既有基于栈区的局部对象，又有基于堆区的全局对象，其中栈区对象的内存由编译器自动分配和释放，而堆区对象的内存则需要由程序员来分配和释放；而在Java中，由于所有对象都在堆内存区，废弃对象所占用的内存都由Java中的垃圾回收器来回收，Java的设计者认为不需要析构函数的存在，这关键在于Java的“不需要人工参与”的垃圾回收机制：<br>　　当你不再需要使用一个对象，或者说，当不存在引用指向某一个对象时，Java虚拟机(JVM)会将该对象标记为释放状态。但是，这并不意味着JVM一定会释放这些对象所占用的内存，或许只有到程序濒临存储空间被用完的那一刻，对象占用的空间才会得到释放，即使你调用System.gc()方法也不见得一定有效，因为这只是给JVM一个建议，而非命令。<br>　　这便造成了：在C++中，当要销毁某个对象时，必须调用该对象的析构函数，这是可预期的；而在Java中，对象却并非总是被垃圾回收，这是不可预期的。
　　
　　</p>
<h2 id="finalize-的用途"><a href="#finalize-的用途" class="headerlink" title=" - finalize()的用途"></a> - finalize()的用途</h2><p>　　垃圾回收器虽然可以自动回收不再被使用的对象的内存，但是它却也仅限于能够释放通过使用new而获得的存储区域。换句话说，若要释放通过某种创建对象方式以外的方式为对象分配的存储空间，这便是finalize()的用处所在。这主要发生在使用“本地方法”的情况下，本地方法是一种在Java中调用非Java代码的方式。在非Java代码中，也许会调用C的malloc()函数系列来分配存储空间，而且除非调用了free()函数，否则存储空间将得不到释放，从而造成内存泄漏。当然，free()是C和C++中的函数，所以需要在finalize()中用本地方法调用它。<strong>但是，你不可能知道何时——甚至是否——finalize()被调用，因此你不应该依赖于使用finalize方法来回收某些短缺的资源，而必须创建其他的“清理”方法，并且明确地调用它们。</strong><br>　　不过，finalize()还有一个<strong>并不依赖于每次都要被调用</strong>的用法，那就是对象<strong>终结条件</strong>的验证。通俗地讲就是：某个对象要么不被销毁，一旦要被销毁，就应该满足某种终结条件。finali()可以用来检查要被销毁的对象是否满足这种条件。我们通过下面这个例子来进行说明：</p>
<pre><code>class Book {
 　　boolean checkedOut = false;
 　　Book(boolean checkOut) {
  　　checkedOut = checkOut;
　 　}
　　void checkIn() {
 　　checkedOut = false;
　　}
　　public void finalize() {
 　　if(checkedOut)
  　　System.out.println(&quot;Error: checked out&quot;);
 　　// Normally, you&apos;ll also do this:
 　　// super.finalized();
　　}
　　}
　　public class TerminationCondition {
 　　public static void main(String[] args) {
  　　Book novel = new Book(true);
  　　// Proper cleanup:
  　　novel.checkIn();
  　　// Drop the reference, forget to clean up:
  　　new Book(true);
  　　// Force garbage collection &amp; finalization:
  　　System.gc();
 　　}
　　}
</code></pre><p>　　在该例中，任何Book对象在被销毁之前，都应该被被签入(check in)，这便是终结条件。如果由于程序员的失误导致某本书未被签入就使得该对象被销毁的话，finalize()就会发现这一缺陷。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/05/关于Java对象作为参数传递是传值还是传引用的问题/" itemprop="url">
                  关于Java对象作为参数传递是传值还是传引用的问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-05T00:06:53+08:00" content="2016-09-05">
              2016-09-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java基础/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/05/关于Java对象作为参数传递是传值还是传引用的问题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/05/关于Java对象作为参数传递是传值还是传引用的问题/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　在Java中，当对象作为参数传递时，究竟传递的是对象的值，还是对象的引用，这是一个饱受争议的话题。若传的是值，那么函数接收的只是实参的一个副本，函数对形参的操作并不会对实参产生影响；若传的是引用，那么此时对形参的操作则会影响到实参。<br>　　首先我们来看一句代码：</p>
<pre><code>Object obj = new Object();
</code></pre><p>　　这句话的意思是：创建一个Object对象，再创建一个名为obj的引用，让这个引用指向这个对象，如下图所示：</p>
<p>　　<img src="http://static.zybuluo.com/xiangwanpeng/m534oudwg6hzbvdhtjfvc081/1.png" alt="1.png-4.3kB"></p>
<p>  在有了上面的基础之后，我们便来看下面这组在网上很流行的例子：</p>
<h2 id="基本数据类型作为参数传递："><a href="#基本数据类型作为参数传递：" class="headerlink" title="基本数据类型作为参数传递："></a><strong>基本数据类型</strong>作为参数传递：</h2><p>  <strong>例1：</strong></p>
<pre><code>public class test {
    public static void main(String[] args) {
        int i = 1;
        System.out.println(&quot;before change, i = &quot;+i);
        change(i);
        System.out.println(&quot;after change, i = &quot;+i);
    }
    public static void change(int i){
        i = 5;
    }
}
</code></pre><p>　　这个例子不难理解，<strong>当基本数据类型作为参数传递时，传递的是实参值的副本，即传的是值，无论在函数中怎么操作这个副本，实参的值是不会被改变的。</strong>所以以上代码执行的结果是：<br>　　<br>　　before change, i = 1<br>　　after change, i = 1
　　
　　</p>
<h2 id="对象作为参数传递："><a href="#对象作为参数传递：" class="headerlink" title=" 对象作为参数传递："></a> <strong>对象</strong>作为参数传递：</h2><p>　　在下面的例２中，我们把StringBuffer对象作为参数传递到change函数。<br>　　<br>　　<strong>例2：</strong></p>
<pre><code>public class test {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(&quot;Hello &quot;);
        System.out.println(&quot;before change, sb is &quot;+sb.toString());
        change(sb);
        System.out.println(&quot;after change, sb is &quot;+sb.toString());
    }
    public static void change(StringBuffer stringBuffer){
        stringBuffer.append(&quot;world !&quot;);
    }
}
</code></pre><p>　　为了方便推理出结论，我们先直接看程序的运行结果：<br>　　<br>　　before change, sb is Hello<br>　　after change, sb is Hello world !<br>　　<br>　　从输出结果中我们可以发现，sb所指向的对象的值被改变了，那么是否我们可以推论出，在Java中，当对象作为参数传递时，传递的是该对象的引用呢？我们再来看下面这个例子：<br>　　<br>　　<strong>例3：</strong></p>
<pre><code>public class test {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer(&quot;Hello &quot;);
        System.out.println(&quot;before change, sb is &quot;+sb.toString());
        change(sb);
        System.out.println(&quot;after change, sb is &quot;+sb.toString());
    }
    public static void change(StringBuffer stringBuffer){
        stringBuffer = new StringBuffer(&quot;Hi &quot;);
        stringBuffer.append(&quot;world !&quot;);
    }
}
</code></pre><p>　　如果上面的推论是正确的，即Java中对象作为参数传递，实际传递的是该对象的引用，那么在调用change函数之后，原对象的值应该是会改变的，变为“Hi world ！”，但是，当我们运行程序后，结果却是如下所示：<br>　　<br>　　before change, sb is Hello<br>　　after change, sb is Hello<br>　　<br>　　原对象的值并没有被改变，这与上面的推论相矛盾！为什么在Java中，当对象作为参数传递时，有的时候实参被改变了，而有的时候实参并未被改变呢？下面让我们来分析一下其中的原因：<br>　　从文章的开头我们知道，当执行StringBuffer sb = new StringBuffer(“Hello “)时，我们创建了一个指向新建对象“new StringBuffer(“Hello “)”的引用“sb”，如下图所示：<br>　　<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/anm3817nrteem689lbd91j5o/2.png" alt="2.png-3.2kB"><br>　　<br>　　在例2中，当我们调用change函数后，实际上，形参stringBuffer也指向了实参sb所指向的对象，即：<br>　　<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/aho7e9ftz9bf3m25ug2e7exy/3.png" alt="3.png-6.3kB"><br>　　<br>　　那么当我们执行stringBuffer.append(“world !”)后，便通过对象的引用“stringBuffer”修改了对象的值，使之变成了“Hello world ！”，即：<br>　　<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/wjdl6p52tleif0og2ikqdcxs/4.png" alt="4.png-6.6kB"><br>　　<br>　　但是，在例3中的change函数中，我们又新建了一个对象“new StringBuffer(“Hi “)”（这实际上在内存中开辟了一块在原对象地址之外的新区域），这让形参stringBuffer实际指向了这个新建的对象，并将新对象的值设置为“Hi world ！”，即：<br>　　<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/3b6natkftfpqw78eaty73nju/image_1art4suka65r1m4o1a0spgcjr89.png" alt="image_1art4suka65r1m4o1a0spgcjr89.png-10.1kB"><br>　　<br>　　那么我们就不难理解，为何在执行完change函数之后，实参的值仍为“Hello”了。
　　</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>　　综上所述，我们可以得出结论：<strong>在Java中，当对象作为参数传递时，实际上传递的是一份“引用的拷贝”。</strong>
　　
　　</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/image/avatar.png"
               alt="Alan" />
          <p class="site-author-name" itemprop="name">Alan</p>
          <p class="site-description motion-element" itemprop="description">Better late than never.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">45</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">61</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xiangwanpeng" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/2810288024/home" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alan</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/VEN/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/VEN/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/VEN/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/VEN/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/VEN/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/VEN/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"xiangwanpeng"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/VEN/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
