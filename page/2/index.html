<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/VEN/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/VEN/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Better late than never.">
<meta property="og:type" content="website">
<meta property="og:title" content="向万鹏的独立博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="向万鹏的独立博客">
<meta property="og:description" content="Better late than never.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="向万鹏的独立博客">
<meta name="twitter:description" content="Better late than never.">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/2/"/>

  <title> 向万鹏的独立博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">向万鹏的独立博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/07/本地SQL检索方式/" itemprop="url">
                  本地SQL检索方式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-07T22:06:14+08:00" content="2016-12-07">
              2016-12-07
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/07/本地SQL检索方式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/07/本地SQL检索方式/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　Hibernate提供本地SQL查询来完善HQL不能涵盖所有的查询特性。例如，可以通过下面的程序完成插入操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNativeSQL</span><span class="params">()</span></span>&#123;</div><div class="line">		String sql = <span class="string">"INSERT INTO gg_department VALUES(?, ?)"</span>;</div><div class="line">		Query query = session.createSQLQuery(sql);</div><div class="line">		</div><div class="line">		query.setInteger(<span class="number">0</span>, <span class="number">1</span>)</div><div class="line">		     .setString(<span class="number">1</span>, <span class="string">"ATGUIGU"</span>)</div><div class="line">		     .executeUpdate();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>　　注意，本地SQL语句中，gg_department是表名，而不是HQL语句中的类名。<br>　　其实，HQL也支持删除和更新的操作（不支持插入操作），例如，下面的例子演示了用HQL进行删除：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHQLUpdate</span><span class="params">()</span></span>&#123;</div><div class="line">		String hql = <span class="string">"DELETE FROM Department d WHERE d.id = :id"</span>;</div><div class="line">		</div><div class="line">		session.createQuery(hql).setInteger(<span class="string">"id"</span>, <span class="number">1</span>)</div><div class="line">		                        .executeUpdate();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/07/QBC检索方式/" itemprop="url">
                  QBC检索方式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-07T21:58:32+08:00" content="2016-12-07">
              2016-12-07
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/07/QBC检索方式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/07/QBC检索方式/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　QBC查询就是通过使用Hibernate提供的Query By Criteria API来查询对象，这种API封装了SQL语句的动态拼装，对查询提供了更加面向对象的功能接口，下面通过几个Demo来介绍QBC的简单使用方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQBC1</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//1. 创建一个 Criteria 对象</span></div><div class="line">		Criteria criteria = session.createCriteria(Employee.class);</div><div class="line">		</div><div class="line">		<span class="comment">//2. 添加查询条件: 在 QBC 中查询条件使用 Criterion 来表示</span></div><div class="line">		<span class="comment">//Criterion 可以通过 Restrictions 的静态方法得到</span></div><div class="line">		criteria.add(Restrictions.eq(<span class="string">"email"</span>, <span class="string">"SKUMAR"</span>));</div><div class="line">		criteria.add(Restrictions.gt(<span class="string">"salary"</span>, <span class="number">5000F</span>));</div><div class="line">		</div><div class="line">		<span class="comment">//3. 执行查询</span></div><div class="line">		Employee employee = (Employee) criteria.uniqueResult();</div><div class="line">		System.out.println(employee); </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQBC2</span><span class="params">()</span></span>&#123;</div><div class="line">		Criteria criteria = session.createCriteria(Employee.class);</div><div class="line">		</div><div class="line">		<span class="comment">//1. AND: 使用 Conjunction 表示</span></div><div class="line">		<span class="comment">//Conjunction 本身就是一个 Criterion 对象</span></div><div class="line">		<span class="comment">//且其中还可以添加 Criterion 对象</span></div><div class="line">		Conjunction conjunction = Restrictions.conjunction();</div><div class="line">		conjunction.add(Restrictions.like(<span class="string">"name"</span>, <span class="string">"a"</span>, MatchMode.ANYWHERE));</div><div class="line">		Department dept = <span class="keyword">new</span> Department();</div><div class="line">		dept.setId(<span class="number">80</span>);</div><div class="line">		conjunction.add(Restrictions.eq(<span class="string">"dept"</span>, dept));</div><div class="line">		System.out.println(conjunction); </div><div class="line">		</div><div class="line">		<span class="comment">//2. OR</span></div><div class="line">		Disjunction disjunction = Restrictions.disjunction();</div><div class="line">		disjunction.add(Restrictions.ge(<span class="string">"salary"</span>, <span class="number">6000F</span>));</div><div class="line">		disjunction.add(Restrictions.isNull(<span class="string">"email"</span>));</div><div class="line">		</div><div class="line">		criteria.add(disjunction);</div><div class="line">		criteria.add(conjunction);</div><div class="line">		</div><div class="line">		criteria.list();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQBC3</span><span class="params">()</span></span>&#123;</div><div class="line">		Criteria criteria = session.createCriteria(Employee.class);</div><div class="line">		</div><div class="line">		<span class="comment">//统计查询: 使用 Projection 来表示: 可以由 Projections 的静态方法得到</span></div><div class="line">		criteria.setProjection(Projections.max(<span class="string">"salary"</span>));</div><div class="line">		</div><div class="line">		System.out.println(criteria.uniqueResult()); </div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQBC4</span><span class="params">()</span></span>&#123;</div><div class="line">		Criteria criteria = session.createCriteria(Employee.class);</div><div class="line">		</div><div class="line">		<span class="comment">//1. 添加排序</span></div><div class="line">		criteria.addOrder(Order.asc(<span class="string">"salary"</span>));</div><div class="line">		criteria.addOrder(Order.desc(<span class="string">"email"</span>));</div><div class="line">		</div><div class="line">		<span class="comment">//2. 添加翻页方法</span></div><div class="line">		<span class="keyword">int</span> pageSize = <span class="number">5</span>;</div><div class="line">		<span class="keyword">int</span> pageNo = <span class="number">3</span>;</div><div class="line">		criteria.setFirstResult((pageNo - <span class="number">1</span>) * pageSize)</div><div class="line">		        .setMaxResults(pageSize)</div><div class="line">		        .list();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/07/HQL检索方式/" itemprop="url">
                  HQL检索方式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-07T16:39:14+08:00" content="2016-12-07">
              2016-12-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hibernate/" itemprop="url" rel="index">
                    <span itemprop="name">Hibernate</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/07/HQL检索方式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/07/HQL检索方式/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Hibernate检索对象的方式"><a href="#Hibernate检索对象的方式" class="headerlink" title="Hibernate检索对象的方式"></a>Hibernate检索对象的方式</h2><p>　　Hibernate提供了以下集中检索对象的方式：</p>
<ul>
<li>导航对象图检索方式：即根据已经加载的对象导航到其他对象。</li>
<li>OID检索方式：按照对象的OID来检索对象。</li>
<li>HQL检索方式：使用面向对象的HQL查询语言。</li>
<li>QBC检索方式：使用QBC（Query By Criteria）。 API来检索对象，这种API封装了基于字符串形式的查询语句，提供了更加面向对象的查询接口。</li>
<li>本地SQL检索方式：使用本地数据库的SQL查询语句。</li>
</ul>
<h2 id="HQL检索方式"><a href="#HQL检索方式" class="headerlink" title="HQL检索方式"></a>HQL检索方式</h2><p>　　本文主要介绍HQL检索方式。<br>　　HQL（Hibernate Query Language）是面向对象的查询语言，它和SQL查询语言有些相似。在Hibernate提供的各种检索方式中，HQL是使用最广的一种检索方式。<strong>它有如下功能</strong>：<br>　　在查询语句中设定各种查询条件；<br>　　支持投影查询；<br>　　支持分页查询；<br>　　支持连接查询<br>　　支持分组查询，允许使用HAVING和GROUP BY关键字；<br>　　提供内置聚集函数，如sum()，min()和max()；<br>　　支持子查询；<br>　　支持动态绑定参数；<br>　　能够调用用户定义的SQL函数或标准的SQL函数。<br>　<br>　　<strong>HQL检索方式包括以下步骤：</strong><br>　　1.通过Session的createQuery()方法创建一个Query对象，它包括一个HQL查询语句，HQL语句中可以包含命名参数；<br>　　2.动态绑定参数；<br>　　3.调用Query相关方法执行查询语句。<br>　<br>　　Query接口支持方法链编程风格，它的setXxx()方法返回自身实例，而不是void类型。<br> 　　<strong>HQL VS SQL：</strong><br>　　HQL查询语句是面向对象的，Hibernate负责解析HQL查询语句，然后根据对象-关系映射文件中的映射信息，把HQL查询语句翻译成相应的SQL语句。HQL查询语句中的主体时域模型中的类及类的属性。<br>　　SQL查询语句是与关系数据库绑定在一起的。SQL查询语句中的主体时数据库表及表的字段。<br>　　<br>　　<strong>绑定参数：</strong><br>　　Hibernate的参数绑定机制依赖于JDBC API中的PreparedStatement的预定义SQL语句功能。<br>　　HQL的参数绑定有两种形式：<br>　　1.按参数名绑定：在HQL查询语句中定义命名参数，命名参数以”:”开头；<br>　　2.按参数位置绑定：在HQL查询语句中用”?”来定义参数位置。<br>　　<br>　　Hibernate可以通过setEntity()方法把参数与一个实体对象绑定，还可以通过setParameter()方法来绑定任意类型的参数。<br>　　<br>　　例如，可以通过下面的代码使用基于位置的参数来查询employee表中salary&gt;1000，email字段中包含字符A，且属于部门号为1的部门的记录，查询结果按照salary进行排序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHQL</span><span class="params">()</span></span>&#123;</div><div class="line">		</div><div class="line">		<span class="comment">//1. 创建 Query 对象</span></div><div class="line">		<span class="comment">//基于位置的参数. </span></div><div class="line">		String hql = <span class="string">"FROM Employee e WHERE e.salary &gt; ? AND e.email LIKE ? AND e.dept = ? "</span></div><div class="line">				+ <span class="string">"ORDER BY e.salary"</span>;</div><div class="line">		Query query = session.createQuery(hql);</div><div class="line">		</div><div class="line">		<span class="comment">//2. 绑定参数</span></div><div class="line">		<span class="comment">//Query 对象调用 setXxx 方法支持方法链的编程风格.</span></div><div class="line">		Department dept = <span class="keyword">new</span> Department();</div><div class="line">		dept.setId(<span class="number">1</span>); </div><div class="line">		query.setFloat(<span class="number">0</span>, <span class="number">1000</span>)</div><div class="line">		     .setString(<span class="number">1</span>, <span class="string">"%A%"</span>)</div><div class="line">		     .setEntity(<span class="number">2</span>, dept);</div><div class="line">		</div><div class="line">		<span class="comment">//3. 执行查询</span></div><div class="line">		List&lt;Employee&gt; emps = query.list();</div><div class="line">		System.out.println(emps.size());  </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>　　在控制台打印的sql语句为：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/c6ezbtfpk73v0a332cjg75gu/image_1b3cb0l9js67eif1hno1988k1d9.png" alt="image_1b3cb0l9js67eif1hno1988k1d9.png-35.9kB"><br>　　<br>　　或者使用基于参数名的参数实现相同的功能：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHQLNamedParameter</span><span class="params">()</span></span>&#123;</div><div class="line">		</div><div class="line">		<span class="comment">//1. 创建 Query 对象</span></div><div class="line">		<span class="comment">//基于命名参数. </span></div><div class="line">		String hql = <span class="string">"FROM Employee e WHERE e.salary &gt; :sal AND e.email LIKE :email AND e.dept = :dept "</span></div><div class="line">				+ <span class="string">"ORDER BY e.salary"</span>;</div><div class="line">		Query query = session.createQuery(hql);</div><div class="line">		</div><div class="line">		<span class="comment">//2. 绑定参数</span></div><div class="line">		<span class="comment">//Query 对象调用 setXxx 方法支持方法链的编程风格.</span></div><div class="line">		Department dept = <span class="keyword">new</span> Department();</div><div class="line">		dept.setId(<span class="number">1</span>); </div><div class="line">		query.setFloat(<span class="string">"sal"</span>, <span class="number">1000</span>)</div><div class="line">		     .setString(<span class="string">"email"</span>, <span class="string">"%A%"</span>)</div><div class="line">		     .setEntity(<span class="string">"dept"</span>, dept);</div><div class="line">		</div><div class="line">		<span class="comment">//3. 执行查询</span></div><div class="line">		List&lt;Employee&gt; emps = query.list();</div><div class="line">		System.out.println(emps.size());  </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h2 id="HQL分页查询"><a href="#HQL分页查询" class="headerlink" title="HQL分页查询"></a>HQL分页查询</h2><p>　　HQL主要通过下面两个方法来实现分页查询：<br>　　<strong>setFirstResult(int firstResult)：</strong>设定从哪一个对象开始检索，参数firstResult指定这个对象在查询结果中的索引位置。索引位置的起始值为0，默认情况下，Query从查询结果中的第一个对象开始检索。<br>　　<strong>setMaxResults(int maxResults)：</strong>设定一次最多检索出的对象的数目。默认情况下，Query和Criteria接口检索出查询结果中的所有的对象。<br>　　<br>　　下面的代码实现了将每5条记录分为一页，查询第4页的记录的功能：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPageQuery</span><span class="params">()</span></span>&#123;</div><div class="line">		String hql = <span class="string">"FROM Employee"</span>;</div><div class="line">		Query query = session.createQuery(hql);</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> pageNo = <span class="number">4</span>;</div><div class="line">		<span class="keyword">int</span> pageSize = <span class="number">5</span>;</div><div class="line">		</div><div class="line">		List&lt;Employee&gt; emps = </div><div class="line">								query.setFirstResult((pageNo - <span class="number">1</span>) * pageSize)</div><div class="line">								     .setMaxResults(pageSize)</div><div class="line">								     .list();</div><div class="line">		System.out.println(emps);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/ktv9a54ka2ewux5x1qk4ix72/image_1b3cdoinmq5a1oegikp8eulfam.png" alt="image_1b3cdoinmq5a1oegikp8eulfam.png-33.5kB"></p>
<h2 id="HQL命名查询"><a href="#HQL命名查询" class="headerlink" title="HQL命名查询"></a>HQL命名查询</h2><p>　　可以在映射文件中定义命名查询语句，实现将HQL语句的外置化，以实现通过不修改源码达到修改功能的效果。下面进行演示：<br>　　<br>在Employee.hbm.xml文件中定义命名查询语句，其中query节点和class节点并列：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">query</span> <span class="attr">name</span>=<span class="string">"salaryEmps"</span>&gt;</span></div><div class="line">&lt;![CDATA[FROM Employee e WHERE e.salary &gt; :minSal AND e.salary &lt; :maxSal]]&gt;<span class="tag">&lt;/<span class="name">query</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>通过session.getNamedQuery()方法查询，参数为上述query节点的name属性值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNamedQuery</span><span class="params">()</span></span>&#123;</div><div class="line">		Query query = session.getNamedQuery(<span class="string">"salaryEmps"</span>);</div><div class="line">		</div><div class="line">		List&lt;Employee&gt; emps = query.setFloat(<span class="string">"minSal"</span>, <span class="number">5000</span>)</div><div class="line">				                   .setFloat(<span class="string">"maxSal"</span>, <span class="number">10000</span>)</div><div class="line">				                   .list();</div><div class="line">		</div><div class="line">		System.out.println(emps.size()); </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h2 id="HQL投影查询"><a href="#HQL投影查询" class="headerlink" title="HQL投影查询"></a>HQL投影查询</h2><p>　　投影查询，即希望查询的结果仅包含实体的部分属性。通过SELECT关键字实现。下面的代码只希望查询指定部门员工的email，salary和dept属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFieldQuery</span><span class="params">()</span></span>&#123;</div><div class="line">		String hql = <span class="string">"SELECT e.email, e.salary, e.dept FROM Employee e WHERE e.dept = :dept"</span>;</div><div class="line">		Query query = session.createQuery(hql);</div><div class="line">		</div><div class="line">		Department dept = <span class="keyword">new</span> Department();</div><div class="line">		dept.setId(<span class="number">1</span>);</div><div class="line">		List&lt;Object[]&gt; result = query.setEntity(<span class="string">"dept"</span>, dept)</div><div class="line">				                     .list();</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(Object [] objs: result)&#123;</div><div class="line">			System.out.println(Arrays.asList(objs));</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这时候，返回的list中的元素是Object数组，其中每一个Object数组中存放了一条记录对应的属性值。<br><img src="http://static.zybuluo.com/xiangwanpeng/2r0jelmwpesu6137ojx5814r/image_1b3celdo5l411kvka45bm1rup13.png" alt="image_1b3celdo5l411kvka45bm1rup13.png-45.9kB"></p>
<p>　　遍历元素为Object数组的list有点麻烦，可以通过另一种方式将查询的属性值存放在一个Employee对象中：先在Employee类中定义一个包含指定属性的构造器，然后通过下面的程序可以查询对应的属性：<br>　　<br>Employee.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String email, <span class="keyword">float</span> salary, Department dept)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.salary = salary;</div><div class="line">		<span class="keyword">this</span>.email = email;</div><div class="line">		<span class="keyword">this</span>.dept = dept;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFieldQuery2</span><span class="params">()</span></span>&#123;</div><div class="line">		String hql = <span class="string">"SELECT new Employee(e.email, e.salary, e.dept) "</span></div><div class="line">				+ <span class="string">"FROM Employee e "</span></div><div class="line">				+ <span class="string">"WHERE e.dept = :dept"</span>;</div><div class="line">		Query query = session.createQuery(hql);</div><div class="line">		</div><div class="line">		Department dept = <span class="keyword">new</span> Department();</div><div class="line">		dept.setId(<span class="number">1</span>);</div><div class="line">		List&lt;Employee&gt; result = query.setEntity(<span class="string">"dept"</span>, dept)</div><div class="line">				                     .list();</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(Employee emp: result)&#123;</div><div class="line">			System.out.println(emp.getId() + <span class="string">", "</span> + emp.getEmail() </div><div class="line">					+ <span class="string">", "</span> + emp.getSalary() + <span class="string">", "</span> + emp.getDept());</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>　　注意构造器中属性顺序需和HQL语句中的属性顺序一致。
　　</p>
<h2 id="HQL报表查询"><a href="#HQL报表查询" class="headerlink" title="HQL报表查询"></a>HQL报表查询</h2><p>　　报表查询用于对数据分组和统计，与SQL一样，HQL利用GROUP BY关键字对数据分组，用HAVING关键字对分组数据设定约束条件。<br>　　在HQL查询语句中可以调用以下聚集函数：<br>　　count()<br>　　min()<br>　　max()<br>　　sum()<br>　　avg()<br>　　下面的代码演示了报表查询，根据department对employee进行分组，然后查询部门内最低工资大于3000的部门的最低工资和最高工资。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGroupBy</span><span class="params">()</span></span>&#123;</div><div class="line">		String hql = <span class="string">"SELECT min(e.salary), max(e.salary) "</span></div><div class="line">				+ <span class="string">"FROM Employee e "</span></div><div class="line">				+ <span class="string">"GROUP BY e.dept "</span></div><div class="line">				+ <span class="string">"HAVING min(salary) &gt; :minSal"</span>;</div><div class="line">		</div><div class="line">		Query query = session.createQuery(hql)</div><div class="line">				             .setFloat(<span class="string">"minSal"</span>, <span class="number">3000</span>);</div><div class="line">		</div><div class="line">		List&lt;Object []&gt; result = query.list();</div><div class="line">		<span class="keyword">for</span>(Object [] objs: result)&#123;</div><div class="line">			System.out.println(Arrays.asList(objs));</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/cmcdbwzlp441eq28y9qv22mh/image_1b3chmnlq30q12et1bi9hdo1erh1g.png" alt="image_1b3chmnlq30q12et1bi9hdo1erh1g.png-29.3kB"></p>
<h2 id="HQL（迫切）左外连接"><a href="#HQL（迫切）左外连接" class="headerlink" title="HQL（迫切）左外连接"></a>HQL（迫切）左外连接</h2><p><strong>迫切左外连接：</strong><br>　　在HQL中通过LEFT JOIN FETCH关键字表示迫切左外连接检索策略。<br>　　list()方法返回的集合<strong>存放实体对象的引用</strong>，<strong>每个Department对象关联的Employee集合都被初始化</strong>，存放所有关联的Employee的实体对象。<br>　　查询结果中可能会包含重复元素，可以通过一个HashSet来过滤重复元素，也可以在HQL语句中使用DISTINCT关键字来过滤。<br>　　下面的例子测试了迫切左外连接：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLeftJoinFetch</span><span class="params">()</span></span>&#123;</div><div class="line">		String hql = <span class="string">"SELECT d FROM Department d LEFT JOIN FETCH d.emps"</span>;</div><div class="line">		Query query = session.createQuery(hql);</div><div class="line">		</div><div class="line">		List&lt;Department&gt; depts = query.list();</div><div class="line">		<span class="comment">//depts = new ArrayList&lt;&gt;(new LinkedHashSet(depts));</span></div><div class="line">		System.out.println(depts.size()); </div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(Department dept: depts)&#123;</div><div class="line">			System.out.println(dept.getName() + <span class="string">"-"</span> + dept.getEmps().size());</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>　　<img src="http://static.zybuluo.com/xiangwanpeng/h4h77y62rn4j1vs4851ce9rf/image_1b3cia2m0ngg1lef1m9v52hoo11t.png" alt="image_1b3cia2m0ngg1lef1m9v52hoo11t.png-26.1kB"><br>　　这种情况下将查询出所有的26条记录（包含重复的department），如果将注释行打开，或者将hql改为”SELECT DISTINCT d FROM Department d LEFT JOIN FETCH d.emps”，可以过滤掉重复元素：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/bz337qd0an8ittdaqpc6udfj/image_1b3cid5q18sfqeh19sl8sg1lfq2a.png" alt="image_1b3cid5q18sfqeh19sl8sg1lfq2a.png-23.9kB"><br>　　<br><strong>左外连接：</strong><br>　　HQL使用LEFT JOIN关键字表示左外连接查询。<br>　　list()方法返回的集合中<strong>存放的是对象数组类型</strong>。（存放了一个Department对象和一个Employee对象）。<br>　　由于list()方法返回的集合中存放的是一个Department对象和一个Employee对象构成的对象数组，所以不能用hashset来去重，因为每一个对象数组其实是不一样的。<br>　　如果需要去重，可以通过SELECT关键字使list()方法返回的集合中仅包含Department对象，然后用DISTINCT来去重。<br>　　可以根据配置文件来决定Employee集合的检索策略。默认情况下是lazy=true，所以当不使用Employee集合时是不会初始化Employee集合的。但是实际上，当查询Department时，Employee集合已经被查出来了，但是没有被初始化，非要等到使用Employee集合的时候再重新去查一遍。所以通常情况下，如果需要使用到表的左外连接，<strong>建议使用迫切的左外连接</strong>，因为反正查department的时候都要把employee集合都查出来，不如直接一次初始化完毕。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLeftJoin</span><span class="params">()</span></span>&#123;</div><div class="line">		String hql = <span class="string">"FROM Department d LEFT JOIN d.emps"</span>;</div><div class="line">		Query query = session.createQuery(hql);</div><div class="line">		</div><div class="line">		List&lt;Object []&gt; result = query.list(); </div><div class="line">		System.out.println(result); </div><div class="line">	</div><div class="line">		<span class="keyword">for</span>(Object [] objs: result)&#123;</div><div class="line">			System.out.println(Arrays.asList(objs));</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>　　<img src="http://static.zybuluo.com/xiangwanpeng/t9fm5a55nqgwn5erdsqbnhna/image_1b3cjvfdievbbg6uofjc91q5o3h.png" alt="image_1b3cjvfdievbbg6uofjc91q5o3h.png-43kB"><br>　　<br>　　可以看到，在查询department后已经将employee都查出来了，但是没有初始化employee集合。<br>　　下面的程序演示了使用SELECT DISTINCT关键字去重。但是，每当使用到employee集合，还要重新select一遍。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLeftJoin</span><span class="params">()</span></span>&#123;</div><div class="line">		String hql = <span class="string">"SELECT DISTINCT d FROM Department d LEFT JOIN d.emps"</span>;</div><div class="line">		Query query = session.createQuery(hql);</div><div class="line">		</div><div class="line">		List&lt;Department&gt; depts = query.list();</div><div class="line">		System.out.println(depts.size());</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(Department dept: depts)&#123;</div><div class="line">			System.out.println(dept.getName() + <span class="string">", "</span> + dept.getEmps().size()); </div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/vsv4izkqn5hrpj6oeb6w19h5/image_1b3cjgbmn3381t4j14o01ctmqoj2n.png" alt="image_1b3cjgbmn3381t4j14o01ctmqoj2n.png-33.7kB"></p>
<h2 id="HQL（迫切）内连接"><a href="#HQL（迫切）内连接" class="headerlink" title="HQL（迫切）内连接"></a>HQL（迫切）内连接</h2><p><strong>迫切内连接：</strong><br>　　HQL使用INNER JOIN FETCH关键字表示迫切内连接，也可以省略INNER关键字。<br>　　list()方法返回的集合中存放<strong>Department对象</strong>的引用，每个Department对象的Employee集合都被初始化，存放所有关联的Employee对象。<br>　　如果希望list()方法返回的集合仅包含Department对象，可以在HQL查询语句中使用SELECT关键字。<br>　　<br><strong>内连接：</strong><br>　　INNER JOIN关键字表示内连接，也可以省略INNER关键字。<br>　　list()方法返回的集合中存放的每个元素对应查询结果的一条记录，每个元素都是<strong>对象数组类型</strong>。<br>　　<br>　　（迫切）内连接和（迫切）左外连接的区别仅在于，（迫切）内连接不会返回从表中没有信息与主表对应的记录。例如，在上面的例子中，有的部门员工数为0，即该部门不存在记录department.id=employee.dept_id，但是（迫切）左外连接仍然会返回该记录，但是（迫切）内连接则不会。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLeftJoin</span><span class="params">()</span></span>&#123;</div><div class="line">		String hql = <span class="string">"SELECT DISTINCT d FROM Department d INNER JOIN d.emps"</span>;</div><div class="line">		Query query = session.createQuery(hql);</div><div class="line">		</div><div class="line">		List&lt;Department&gt; depts = query.list();</div><div class="line">		System.out.println(depts.size());</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(Department dept: depts)&#123;</div><div class="line">			System.out.println(dept.getName() + <span class="string">", "</span> + dept.getEmps().size()); </div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/35xr4f5819wwtqgn47u9xnc9/image_1b3cmq14eutk12b7175n1j6s180i4b.png" alt="image_1b3cmq14eutk12b7175n1j6s180i4b.png-29.8kB"><br>　　打印的depts.size()不再是上面的10，而是8，因为有6号部门和10号部门没有员工：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/j5b9yyzsmfh22dgrb5uwm3ck/image_1b3cms4no1g1u1ihguvhnpd16us4o.png" alt="image_1b3cms4no1g1u1ihguvhnpd16us4o.png-44.9kB"><br>　　<img src="http://static.zybuluo.com/xiangwanpeng/4qmpxgpw7qof6f981d510xrs/image_1b3cmsc88rnrtpp1ro5uav1a8155.png" alt="image_1b3cmsc88rnrtpp1ro5uav1a8155.png-7.9kB"><br>　　<br>　　如果用SELECT来查询employee，道理也和上面讲述的时一样的，加FETCH会立即初始化department，不加FETCH则会等到使用department时才分别初始化对应的department。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLeftJoinFetch2</span><span class="params">()</span></span>&#123;</div><div class="line">		String hql = <span class="string">"SELECT e FROM Employee e INNER JOIN FETCH e.dept"</span>;</div><div class="line">		Query query = session.createQuery(hql);</div><div class="line">		</div><div class="line">		List&lt;Employee&gt; emps = query.list();</div><div class="line">		System.out.println(emps.size()); </div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(Employee emp: emps)&#123;</div><div class="line">			System.out.println(emp.getName() + <span class="string">", "</span> + emp.getDept().getName());</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/fdjkjs6erjwtn2381xkb6tat/image_1b3cng6hj1mc319vk7lfdr75j5i.png" alt="image_1b3cng6hj1mc319vk7lfdr75j5i.png-25.7kB"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLeftJoinFetch2</span><span class="params">()</span></span>&#123;</div><div class="line">		String hql = <span class="string">"SELECT e FROM Employee e INNER JOIN e.dept"</span>;</div><div class="line">		Query query = session.createQuery(hql);</div><div class="line">		</div><div class="line">		List&lt;Employee&gt; emps = query.list();</div><div class="line">		System.out.println(emps.size()); </div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(Employee emp: emps)&#123;</div><div class="line">			System.out.println(emp.getName() + <span class="string">", "</span> + emp.getDept().getName());</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/7gj5y0ir50nr6gaacbtq9gao/image_1b3cniba6tfmm318hu1ar51djl5v.png" alt="image_1b3cniba6tfmm318hu1ar51djl5v.png-41kB"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/07/Hibernate检索策略/" itemprop="url">
                  Hibernate检索策略
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-07T12:45:48+08:00" content="2016-12-07">
              2016-12-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hibernate/" itemprop="url" rel="index">
                    <span itemprop="name">Hibernate</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/07/Hibernate检索策略/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/07/Hibernate检索策略/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>检索策略追求的两个目标是：（以客户和订单的例子说明）</p>
<ul>
<li>不浪费内存：当Hibernate从数据库中加载Customer对象时，如果同时加载所有关联的Order对象，而程序实际上仅仅需要访问Customer对象，那么这些关联的Order对象就白白浪费了许多内存。</li>
<li>更高的查询效率：发送尽可能少的SQL语句。</li>
</ul>
<h2 id="类级别的检索策略"><a href="#类级别的检索策略" class="headerlink" title="类级别的检索策略"></a>类级别的检索策略</h2><p>　　类级别可选的检索策略包括立即检索和延迟检索，默认为延迟检索。<br>　　<strong>立即检索:</strong> 立即加载检索方法指定的对象。<br>　　<strong>延迟检索:</strong> 延迟加载检索方法指定的对象。在使用具体的属性时，再进行加载。<br>　　类级别的检索策略可以通过在映射文件中的<strong>&lt;class&gt;</strong>元素的<strong>lazy</strong>属性进行设置，默认为true。<br>　　如果程序加载一个对象的目的是为了访问它的属性，可以采取立即检索。<br>　　如果程序加载一个持久化对象的目的是仅仅为了获得它的引用，可以采用延迟检索。注意延迟检索可能会出现懒加载异常。<br>　　无论&lt;class&gt;元素的lazy属性是true还是false， <strong>仅是只对Session的load方法起作用，因为Session的get方法及Query的list方法在类级别总是使用立即检索策略。</strong>若&lt;class&gt;元素的lazy属性为true或取默认值，Session的load()方法不会执行查询数据表的SELECT语句，仅返回代理类对象的实例，该代理类实例有如下特征：</p>
<ol>
<li>由Hibernate 在运行时采用CGLIB工具动态生成；</li>
<li>Hibernate创建代理类实例时，仅初始化其 OID 属性；</li>
<li>在应用程序第一次访问代理类实例的非OID属性时，Hibernate 会初始化代理类实例。</li>
</ol>
<p>　　
　　</p>
<h2 id="一对多和多对多的检索策略"><a href="#一对多和多对多的检索策略" class="headerlink" title="一对多和多对多的检索策略"></a>一对多和多对多的检索策略</h2><p>　　在映射文件中，用&lt;set&gt;元素来配置一对多关联及多对多关联关系，&lt;set&gt;元素有下面三个属性。<br><strong>lazy属性：</strong>主要决定orders集合被初始化的时机。即到底是在加载Customer对象时就被初始化，还是在程序访问orders集合时被初始化。<br><strong>batch-size属性：</strong>用来为延迟检索策略或立即检索策略设定批量检索的数量。批量检索能减少SELECT语句的数目，提高延迟检索或立即检索的运行性能。<br><strong>fetch属性：</strong><br>　　若取值为”select”或”subselect”，用来指定初始化orders的查询语句的形式，当fetch属性为”subselect”时，假定Session缓存中有n个orders集合代理类实例没有被初始化，Hibernate能够通过带子查询的select语句，来批量初始化n个orders集合代理类实例，此时，batch-size属性将被忽略，子查询中的select语句为查询CUSTOMERS表OID的SELECT语句。<br>　　若取值为”join”，则指定orders集合被初始化的时机。若把fetch设置为 “join”，则在检索Customer对象时，会采用迫切左外连接策略来检索所有关联的Order对象，此时，lazy属性将被忽略。迫切左外连接检索策略的优点在于使用更少的select语句。注意，Query的list方法会忽略映射文件中配置的迫切左外连接检索策略，而依旧采用延迟加载策略。</p>
<p>lazy属性和fetch属性的可能组合如下图所示：</p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/bqu8il7ddgwl06rwhooo5cc1/image_1b3bqsmcrqsg1ndfvpm1s4uah9.png" alt="image_1b3bqsmcrqsg1ndfvpm1s4uah9.png-196.8kB"></p>
<p><strong>关于延迟检索和增强延迟检索：</strong></p>
<ul>
<li>在<strong>延迟检索(lazy属性值为true)</strong>集合属性时，Hibernate在以下情况下初始化集合代理类实例：<ol>
<li>应用程序第一次调用集合的iterator()，size()，isEmpty()， contains()等方法访问集合的属性时。</li>
<li>通过Hibernate.initialize()静态方法显式初始化时。</li>
</ol>
</li>
<li><strong>增强延迟检索(lazy属性为extra)</strong>，与lazy=”true”类似，主要区别是增强延迟检索策略能<strong>进一步延迟</strong> Customer对象的orders集合代理实例的初始化时机：<ol>
<li>当程序第一次访问orders属性的iterator()方法来遍历元素时，会导致orders集合代理类实例的初始化。</li>
<li>当程序第一次访问order属性的size()，contains()和isEmpty()方法时，Hibernate<strong>不会初始化</strong>orders集合类的实例，仅通过特定的select语句查询必要的信息，而不会检索所有的Order对象。</li>
</ol>
</li>
</ul>
<h2 id="多对一和一对一关联的检索策略"><a href="#多对一和一对一关联的检索策略" class="headerlink" title="多对一和一对一关联的检索策略"></a>多对一和一对一关联的检索策略</h2><p>　　和&lt;set&gt;一样，&lt;many-to-one&gt;节点也有一个lazy属性和一个fetch属性，如下图所示：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/qvedpw9064ysr71ifxnygwkr/image_1b3brrg3o1oqg5m11irogui1i1mm.png" alt="image_1b3brrg3o1oqg5m11irogui1i1mm.png-89.4kB"><br>　　<br>　　且同上述一样，若fetch设为join，那么lazy属性将被忽略。<br>　　<br>下面总结一下各种检索策略：<br>　<br><img src="http://static.zybuluo.com/xiangwanpeng/0kpvpbxezag492v94flfq7pa/image_1b3bs3qahkeubm539c1fe51cli13.png" alt="image_1b3bs3qahkeubm539c1fe51cli13.png-180.4kB">
　　</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/06/Hibernate的多对多关联关系（单向和双向）/" itemprop="url">
                  Hibernate的多对多关联关系（单向和双向）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-06T18:11:22+08:00" content="2016-12-06">
              2016-12-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hibernate/" itemprop="url" rel="index">
                    <span itemprop="name">Hibernate</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/06/Hibernate的多对多关联关系（单向和双向）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/06/Hibernate的多对多关联关系（单向和双向）/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　n-n（多对多）的关联关系必须通过连接表实现。下面以商品种类和商品之间的关系，即一个商品种类下面可以有多种商品，一种商品又可以属于多个商品种类，分别介绍单向的n-n关联关系和双向的n-n关联关系。</p>
<h2 id="单向的n-n关联关系"><a href="#单向的n-n关联关系" class="headerlink" title="单向的n-n关联关系"></a>单向的n-n关联关系</h2><p>　　如果仅使用两张数据表，是不能实现n-n的关联关系的，如下图：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/92cmcpcflcg3pd06l6qkmjkp/image_1b39rjpnd1pi81qv738a15pi1rbv13.png" alt="image_1b39rjpnd1pi81qv738a15pi1rbv13.png-27.6kB"><br>　　商品ITEM_AA属于商品种类CATEGORY_AA，但是如果商品ITEM_AA又同时属于商品种类CATEGORY_BB呢，两张数据表无法实现这种关系，所以我们需要使用到连接表，如下图所示：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/wvdd8tpizlt758prfclkd3pv/image_1b39rmve8rui1n6u4lemavnk1g.png" alt="image_1b39rmve8rui1n6u4lemavnk1g.png-34.6kB"><br>　　我们添加一张连接表，其中的每一条记录表示某一个商品和某一个商品种类的对应关系。<br>　　单向的n-n关联关系的域模型和关系数据模型如下图所示：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/fpa259k78ap8lq50nkas2msl/image_1b39rdrgb16fp143n1hrtkv23fum.png" alt="image_1b39rdrgb16fp143n1hrtkv23fum.png-82.5kB"><br>　　下面来实现这种关系，首先新建两个类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Category</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Integer id;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Set&lt;Item&gt; items = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="comment">//getters and setters</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Integer id;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	</div><div class="line">	<span class="comment">//getters and setters</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生成并编辑映射文件：<br>　<br>Category.hbm.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></div><div class="line">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.atguigu.hibernate.n2n"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Category"</span> <span class="attr">table</span>=<span class="string">"CATEGORIES"</span>&gt;</span></div><div class="line">    </div><div class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"ID"</span> /&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">    </div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"NAME"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="comment">&lt;!-- table: 指定中间表 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"items"</span> <span class="attr">table</span>=<span class="string">"CATEGORIES_ITEMS"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"C_ID"</span> /&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">key</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- 使用 many-to-many 指定多对多的关联关系. column 执行 Set 集合中的持久化类在中间表的外键列的名称  --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">"Item"</span> <span class="attr">column</span>=<span class="string">"I_ID"</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-many</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">        </div><div class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>Item.hbm.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></div><div class="line">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.atguigu.hibernate.n2n.Item"</span> <span class="attr">table</span>=<span class="string">"ITEMS"</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"ID"</span> /&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"NAME"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>　　与1-n关联关系类似，在映射时，必须在category类的映射文件中设置set节点。但是不同的是，在set节点中指定的表为连接表CATEGORIES_ITEMS，而不再是所关联的类Item所对应的表，而且，在set节点中设置的是many-to-many节点，而不再是one-to-many。many-to-many节点的class属性指定了items集合中存放的对象类型是Item，colume属性指定了连接表CATEGORIES_ITEMS中参照ITEMS表的外键是ITEM_ID。<br>　　现在随便一个测试程序，发现除了生成了表CATEGORIES和表ITEMS，还生成了连接表CATEGORIES_ITEMS，表结构为：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/dfrx1jk77u0znnwn5z6rhibn/image_1b39sup4kk251768905q88mp3h.png" alt="image_1b39sup4kk251768905q88mp3h.png-17.9kB"><br>　　　<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/e93f1ch1woevh96msj8kfdll/image_1b39srd5u68vmnn1rboe841m8c2a.png" alt="image_1b39srd5u68vmnn1rboe841m8c2a.png-19.8kB"><br>　　<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/xopgp561lmoluifl41p6gk62/image_1b39ss3o61adjk5i11pbcorv692n.png" alt="image_1b39ss3o61adjk5i11pbcorv692n.png-16.6kB"><br>　　<img src="http://static.zybuluo.com/xiangwanpeng/l59i5j07bmx0uo0xa59zhsjq/image_1b39st1rd1ve880v139411iec2o34.png" alt="image_1b39st1rd1ve880v139411iec2o34.png-20.4kB"><br>　　<br>下面测试save操作和get操作：<br>　　<br><strong>单向n-n关联关系的save操作：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span></span>&#123;</div><div class="line">		Category category1 = <span class="keyword">new</span> Category();</div><div class="line">		category1.setName(<span class="string">"C-AA"</span>);</div><div class="line"></div><div class="line">		Category category2 = <span class="keyword">new</span> Category();</div><div class="line">		category2.setName(<span class="string">"C-BB"</span>);</div><div class="line">		</div><div class="line">		Item item1 = <span class="keyword">new</span> Item();</div><div class="line">		item1.setName(<span class="string">"I-AA"</span>);</div><div class="line">		</div><div class="line">		Item item2 = <span class="keyword">new</span> Item();</div><div class="line">		item2.setName(<span class="string">"I-BB"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">//设定关联关系</span></div><div class="line">		category1.getItems().add(item1);</div><div class="line">		category1.getItems().add(item2);</div><div class="line">		</div><div class="line">		category2.getItems().add(item1);</div><div class="line">		category2.getItems().add(item2);</div><div class="line">		</div><div class="line">		<span class="comment">//执行保存操作</span></div><div class="line">		session.save(category1);</div><div class="line">		session.save(category2);</div><div class="line">		</div><div class="line">		session.save(item1);</div><div class="line">		session.save(item2);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>　　运行程序，根据控制台打印的sql语句，发现会先往CATEGORIES表和ITEMS表分别插入两条记录，然后再往连接表CATEGORIES_ITEMS插入四条记录，这是符合我们的预期的：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/lbjemsf52jr4740wl13e8sg7/image_1b39tavqsr1pt8k1p2t1t4obkh3u.png" alt="image_1b39tavqsr1pt8k1p2t1t4obkh3u.png-45.7kB"><br>　　<img src="http://static.zybuluo.com/xiangwanpeng/7xrrd4d05035y0zbxsmz8pdx/image_1b39tbqdjs8b5gv6jc1q3tob74b.png" alt="image_1b39tbqdjs8b5gv6jc1q3tob74b.png-35.3kB"><br>　　　<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/yhg6hh4wwh4ly2giyk3ez2jg/image_1b39tc9ha1vs4ghpk69184lfi4o.png" alt="image_1b39tc9ha1vs4ghpk69184lfi4o.png-12kB"><br>　　<img src="http://static.zybuluo.com/xiangwanpeng/bzlvst6ac0zw0zlqi1igrv7v/image_1b39tcgol9ki11v81o2bjgb1i3e55.png" alt="image_1b39tcgol9ki11v81o2bjgb1i3e55.png-12.5kB"><br>　　<img src="http://static.zybuluo.com/xiangwanpeng/pw63315xeadahscuxji09hc3/image_1b39tcqfl1q8k72e1fd4n2117gp5i.png" alt="image_1b39tcqfl1q8k72e1fd4n2117gp5i.png-10.9kB"><br>　　<br><strong>单向n-n关联关系的get操作：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGet</span><span class="params">()</span></span>&#123;</div><div class="line">		Category category = (Category) session.get(Category.class, <span class="number">1</span>);</div><div class="line">		System.out.println(category.getName()); </div><div class="line">		</div><div class="line">		<span class="comment">//需要连接中间表</span></div><div class="line">		Set&lt;Item&gt; items = category.getItems();</div><div class="line">		System.out.println(items.size()); </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>　　同之前的1-n、1-1中类似，先查询category会使用懒加载机制，不会立即加载items，只有使用到items的时候才会加载。当加载items的时候，是通过内连接连接中间表CATEGORIES_ITEMS进行查询的：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/gjdtiwym4o9b0132la6qnivc/image_1b39u7n5a1qfflau1q9d1n9v1kd55v.png" alt="image_1b39u7n5a1qfflau1q9d1n9v1kd55v.png-32.1kB">
　　</p>
<h2 id="双向的n-n关联关系"><a href="#双向的n-n关联关系" class="headerlink" title="双向的n-n关联关系"></a>双向的n-n关联关系</h2><p>　　在双向的n-n关联关系中，两端的类都需要使用集合属性，即Category中要包含一个Set&lt;Item&gt;，Item中也要包含一个Set&lt;Category&gt;，，且在数据库中同样需要使用连接表连接。其域模型和关系数据模型如下：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/ysvxx8eaqa30ksvgqxgv0byv/image_1b39ucin71p3okqd5vhhjop4j6c.png" alt="image_1b39ucin71p3okqd5vhhjop4j6c.png-84kB"><br>　　<br>　　下面编写代码，首先创建两个类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Category</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Integer id;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Set&lt;Item&gt; items = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="comment">//getters and setters</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Integer id;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Set&lt;Category&gt; categories = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="comment">//getters and setters</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生成并编辑映射文件：<br>　<br>Category.hbm.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></div><div class="line">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.atguigu.hibernate.n2n"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Category"</span> <span class="attr">table</span>=<span class="string">"CATEGORIES"</span>&gt;</span></div><div class="line">    </div><div class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"ID"</span> /&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">    </div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"NAME"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="comment">&lt;!-- table: 指定中间表 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"items"</span> <span class="attr">table</span>=<span class="string">"CATEGORIES_ITEMS"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"C_ID"</span> /&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">key</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- 使用 many-to-many 指定多对多的关联关系. column 执行 Set 集合中的持久化类在中间表的外键列的名称  --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">"Item"</span> <span class="attr">column</span>=<span class="string">"I_ID"</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-many</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">        </div><div class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>Item.hbm.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></div><div class="line">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.atguigu.hibernate.n2n.Item"</span> <span class="attr">table</span>=<span class="string">"ITEMS"</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"ID"</span> /&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"NAME"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"categories"</span> <span class="attr">table</span>=<span class="string">"CATEGORIES_ITEMS"</span> <span class="attr">inverse</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">        	<span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"I_ID"</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></div><div class="line">        	<span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">"com.atguigu.hibernate.n2n.Category"</span> <span class="attr">column</span>=<span class="string">"C_ID"</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-many</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">        </div><div class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>　　大部门内容和单向n-n中类似，只是需要在Item类中添加字段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　<span class="keyword">private</span> Set&lt;Category&gt; categories = <span class="keyword">new</span> HashSet&lt;&gt;();</div></pre></td></tr></table></figure></p>
<p>并且需要在Item类的映射文件中像Category映射文件中那样配置set节点。此外，还有一个很重要的地方，就是需要在Category和Item的其中一端的映射文件中的set节点中设置inverse=”true”属性，以放弃维护关联关系，否则两端都会维护默认关系，这在某些情况下会导致错误，下面会演示。<br>　　现在生成数据表，表结构和单向n-n中一样：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/dfrx1jk77u0znnwn5z6rhibn/image_1b39sup4kk251768905q88mp3h.png" alt="image_1b39sup4kk251768905q88mp3h.png-17.9kB"><br>　　　<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/e93f1ch1woevh96msj8kfdll/image_1b39srd5u68vmnn1rboe841m8c2a.png" alt="image_1b39srd5u68vmnn1rboe841m8c2a.png-19.8kB"><br>　　<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/xopgp561lmoluifl41p6gk62/image_1b39ss3o61adjk5i11pbcorv692n.png" alt="image_1b39ss3o61adjk5i11pbcorv692n.png-16.6kB"><br>　　<img src="http://static.zybuluo.com/xiangwanpeng/l59i5j07bmx0uo0xa59zhsjq/image_1b39st1rd1ve880v139411iec2o34.png" alt="image_1b39st1rd1ve880v139411iec2o34.png-20.4kB"></p>
<p>　　下面测试save操作和get操作：<br>　　<br><strong>双向n-n关联关系的save操作：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">Category category1 = <span class="keyword">new</span> Category();</div><div class="line">		category1.setName(<span class="string">"C-AA"</span>);</div><div class="line"></div><div class="line">		Category category2 = <span class="keyword">new</span> Category();</div><div class="line">		category2.setName(<span class="string">"C-BB"</span>);</div><div class="line">		</div><div class="line">		Item item1 = <span class="keyword">new</span> Item();</div><div class="line">		item1.setName(<span class="string">"I-AA"</span>);</div><div class="line">		</div><div class="line">		Item item2 = <span class="keyword">new</span> Item();</div><div class="line">		item2.setName(<span class="string">"I-BB"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">//设定关联关系</span></div><div class="line">		category1.getItems().add(item1);</div><div class="line">		category1.getItems().add(item2);</div><div class="line">		</div><div class="line">		category2.getItems().add(item1);</div><div class="line">		category2.getItems().add(item2);</div><div class="line">		</div><div class="line">		item1.getCategories().add(category1);</div><div class="line">		item1.getCategories().add(category2);</div><div class="line">		</div><div class="line">		item2.getCategories().add(category1);</div><div class="line">		item2.getCategories().add(category2);</div><div class="line">		</div><div class="line">		<span class="comment">//执行保存操作</span></div><div class="line">		session.save(category1);</div><div class="line">		session.save(category2);</div><div class="line">		</div><div class="line">		session.save(item1);</div><div class="line">		session.save(item2);</div></pre></td></tr></table></figure></p>
<p>　　运行程序，和单向n-n中一样，一共打印8条insert语句，并成功插入记录。但是，现在我们移除Item.hbm.xml文件中的inverse=”true”属性，再运行程序，会抛出异常。这是因为在默认情况下n-n的两端都会维护关联关系，当执行上述四条save代码后，category要维护关联关系，往连接表中添加4条记录，然后item也要维护关联关系，往连接表中添加相同的4条记录，会导致连接表中主键重复，解决方法就是在Item.hbm.xml文件中设置inverse=”true”属性。<br><strong>双向n-n关联关系的get操作：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGet</span><span class="params">()</span></span>&#123;</div><div class="line">		Category category = (Category) session.get(Category.class, <span class="number">1</span>);</div><div class="line">		System.out.println(category.getName()); </div><div class="line">		</div><div class="line">		<span class="comment">//需要连接中间表</span></div><div class="line">		Set&lt;Item&gt; items = category.getItems();</div><div class="line">		System.out.println(items.size()); </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>　　双向n-n关联关系的get操作和单向n-n中一样，包含懒加载机制和内连接。<br>　　补充一下，双向n-n中两端的映射文件的字段对应如下图所示：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/3qux1rqie8xct5ol9wqc1vez/image_1b3a0lgva19hamhlrjs1g461gj66p.png" alt="image_1b3a0lgva19hamhlrjs1g461gj66p.png-146.2kB"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/05/Hibernate的一对一关联关系/" itemprop="url">
                  Hibernate的一对一关联关系
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-05T12:52:37+08:00" content="2016-12-05">
              2016-12-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hibernate/" itemprop="url" rel="index">
                    <span itemprop="name">Hibernate</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/05/Hibernate的一对一关联关系/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/05/Hibernate的一对一关联关系/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　Hibernate的一对一关联关系，分为基于外键的一对一关联关系和基于主键的一对一关联关系。在这篇文章中，我们以部门和部门经理的例子来说明，一个部门对应唯一一个部门经理，一个部门经理也对应唯一一个部门。<br>　　在基于外键的一对一关联关系中，一端通过一个主键以外的字段关联另一端的主键，如下图所示：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/6n98z7fye9u1a0nfdak6tntp/E3CF6A0B-55EB-43AE-BDBC-D2DB80C116EF.jpg" alt="E3CF6A0B-55EB-43AE-BDBC-D2DB80C116EF.jpg-8.3kB"><br>　　　<br>　　在基于主键的一对一关联关系中，一端直接通过主键关联另一端的主键，并通过另一端的主键生成自己的主键，如下图所示：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/w43ax64nxy864mic5e290ltl/image_1b36lr2j11khlidodn5i5e1net12.png" alt="image_1b36lr2j11khlidodn5i5e1net12.png-22.9kB"><br>　　　<br>　　下面进行详细说明。</p>
<h2 id="基于外键的一对一关联关系"><a href="#基于外键的一对一关联关系" class="headerlink" title="基于外键的一对一关联关系"></a>基于外键的一对一关联关系</h2><p>　　对于基于外键的1-1关联关系，外键可以存放在任意一端，例如在本例中，外键既可以存放在department一端，也可以存放在manager一端，我们假设存放在department一端。在需要存放外键的一端，增加<strong>many-to-one</strong>节点，并且为many-to-one节点添加<strong>unique=”true”</strong>属性，来表示为1-1关联，添加unique=”true”属性了以后，不同的department就不能关联同一个manager了。在不存放外键的一端，需要使用<strong>one-to-one</strong>节点，并且在该节点中添加<strong>property-ref</strong>属性来指定存放外键一端的除主键以外的字段来作为关联字段。代码如下，首先创建两个类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Integer deptId;</div><div class="line">	<span class="keyword">private</span> String deptName;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Manager mgr;</div><div class="line">	</div><div class="line">	<span class="comment">//getters and setters</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Integer mgrId;</div><div class="line">	<span class="keyword">private</span> String mgrName;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Department dept;</div><div class="line">	</div><div class="line">	<span class="comment">//getters and setters</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>映射文件：<br>　<br>Department.hbm.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></div><div class="line">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.atguigu.hibernate.one2one.foreign.Department"</span> <span class="attr">table</span>=<span class="string">"DEPARTMENTS"</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"deptId"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"DEPT_ID"</span> /&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"deptName"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"DEPT_NAME"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">		</div><div class="line">		<span class="comment">&lt;!-- 使用 many-to-one 的方式来映射 1-1 关联关系 --&gt;</span></div><div class="line">		<span class="comment">&lt;!-- 添加unique="true"属性，来表示为1-1关联 --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"mgr"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.hibernate.one2one.foreign.Manager"</span> </span></div><div class="line">			<span class="attr">column</span>=<span class="string">"MGR_ID"</span> <span class="attr">unique</span>=<span class="string">"true"</span>&gt;<span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span>	        </div><div class="line">			        </div><div class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>Manager.hbm.xml<br>　<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></div><div class="line">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.atguigu.hibernate.one2one.foreign.Manager"</span> <span class="attr">table</span>=<span class="string">"MANAGERS"</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"mgrId"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"MGR_ID"</span> /&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mgrName"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"MGR_NAME"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="comment">&lt;!-- 映射 1-1 的关联关系: 在对应的数据表中已经有外键了, 当前持久化类使用 one-to-one 进行映射 --&gt;</span></div><div class="line">        <span class="comment">&lt;!-- </span></div><div class="line">        	没有外键的一端需要使用one-to-one元素，该元素使用 property-ref 属性指定使用被关联实体主键以外的字段作为关联字段</div><div class="line">         --&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"dept"</span> </span></div><div class="line">        	<span class="attr">class</span>=<span class="string">"com.atguigu.hibernate.one2one.foreign.Department"</span></div><div class="line">        	<span class="attr">property-ref</span>=<span class="string">"mgr"</span>&gt;<span class="tag">&lt;/<span class="name">one-to-one</span>&gt;</span></div><div class="line">        </div><div class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></div><div class="line">    </div><div class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>运行一个空的test程序，可以生成数据库表managers和departments：<br>　<br><img src="http://static.zybuluo.com/xiangwanpeng/fawyabzs4rzipfxaweyb85tq/image_1b36mlbre1tev98d1f9rusbiu91f.png" alt="image_1b36mlbre1tev98d1f9rusbiu91f.png-19kB"><br>　<br><img src="http://static.zybuluo.com/xiangwanpeng/cxxs4hnb25972ihf3h98m2nb/image_1b36mmdvq19lu1o681ehs1sgc1gmh1s.png" alt="image_1b36mmdvq19lu1o681ehs1sgc1gmh1s.png-19.8kB"><br><img src="http://static.zybuluo.com/xiangwanpeng/zahad34vc7axxxjdt1ski1fe/image_1b36mmu0n1qp61tpek735sbdfr29.png" alt="image_1b36mmu0n1qp61tpek735sbdfr29.png-18.9kB"></p>
<p>下面测试基于外键的1-1关联关系的save和get操作：</p>
<p><strong>基于外键的1-1关联关系的save操作：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span></span>&#123;</div><div class="line">		</div><div class="line">		Department department = <span class="keyword">new</span> Department();</div><div class="line">		department.setDeptName(<span class="string">"DEPT-BB"</span>);</div><div class="line">		</div><div class="line">		Manager manager = <span class="keyword">new</span> Manager();</div><div class="line">		manager.setMgrName(<span class="string">"MGR-BB"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">//设定关联关系</span></div><div class="line">		department.setMgr(manager);</div><div class="line">		manager.setDept(department);</div><div class="line">		</div><div class="line">		<span class="comment">//保存操作</span></div><div class="line">		<span class="comment">//建议先保存没有外键列的那个对象. 这样会减少 UPDATE 语句</span></div><div class="line">			session.save(manager);</div><div class="line">			session.save(department);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>　　这段代码可以正常插入记录。和n-1关联关系中一样，如果先保存了存放外键一端的对象，后保存被外键关联的一端的对象，即如果先执行session.save(department);，后执行session.save(manager);，虽然同样可以正确保存，但是会多出一条update语句用于维护关联关系，所以通常建议先插入没有外键一端的对象，后插入有外键一端的对象。<br>　　<br><strong>基于外键的1-1关联关系的get操作：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGet</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//1. 默认情况下对关联属性使用懒加载</span></div><div class="line">		Department dept = (Department) session.get(Department.class, <span class="number">1</span>);</div><div class="line">		System.out.println(dept.getDeptName()); </div><div class="line">		</div><div class="line">		<span class="comment">//2. 所以会出现懒加载异常的问题. </span></div><div class="line"><span class="comment">//		session.close();</span></div><div class="line"><span class="comment">//		Manager mgr = dept.getMgr();</span></div><div class="line"><span class="comment">//		System.out.println(mgr.getClass()); </span></div><div class="line"><span class="comment">//		System.out.println(mgr.getMgrName()); </span></div><div class="line">		</div><div class="line">		<span class="comment">//3. 查询 Manager 对象的连接条件应该是 dept.manager_id = mgr.manager_id</span></div><div class="line">		<span class="comment">//而不应该是 dept.dept_id = mgr.manager_id</span></div><div class="line">		Manager mgr = dept.getMgr();</div><div class="line">		System.out.println(mgr.getMgrName()); </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>　　同n-1关联关系一样，当查询存放外键的一端的对象department的时候，使用懒加载机制，即不会立即加载它关联的另一端的对象manager，而只有等到要使用manager的时候，才会发送select语句加载。那么同样也有可能发生懒加载异常。运行结果如下图所示：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/hgn1k9i2hj6yzuuz0nuam433/image_1b36o9f1j1a1mss9i951atf1cqh2m.png" alt="image_1b36o9f1j1a1mss9i951atf1cqh2m.png-65.3kB"><br>　　值得注意的是，当要使用到manager对象时，是通过左外连接查询到manager对象的，连接条件是dept.manager_id = mgr.manager_id，这是正确的，因为我们在Manager.hbm.xml中的one-to-one节点中配置了property-ref=”mgr”，指定关联字段为department的mgr字段。如果没有设置property-ref属性，那么默认关联的字段为department的id字段，例如，我们去掉property-ref=”mgr”的设置，运行testGet()方法，则会打印如下的sql语句（连接条件是dept.dept_id = mgr.manager_id），这显然是不符合需求的。<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/dysuq5g0v5kyq0ulcdocbx6a/image_1b36vjp9k2tp1jum6srtu7bs833.png" alt="image_1b36vjp9k2tp1jum6srtu7bs833.png-35.3kB"><br>　　<br>　　还有一个注意点，就是当首先查询不存放外键的一端的对象时，即manager，由于其中没有设置外键关联到department，所以会使用左外连接查询，一并查询出另一端的对象，即department，而且已经完成了初始化。如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGet2</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//在查询没有外键的实体对象时, 使用的左外连接查询, 一并查询出其关联的对象</span></div><div class="line">		<span class="comment">//并已经进行初始化. </span></div><div class="line">		Manager mgr = (Manager) session.get(Manager.class, <span class="number">1</span>);</div><div class="line">		</div><div class="line">		<span class="comment">//在执行下面的代码之前已经完成了对department对象的初始化</span></div><div class="line">		System.out.println(mgr.getMgrName()); </div><div class="line">		System.out.println(mgr.getDept().getDeptName()); </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="http://static.zybuluo.com/xiangwanpeng/l64u6dmpx0wb9ld9n3s76tu0/image_1b37027r68l01dvj1j2u1dnu14ua3t.png" alt="image_1b37027r68l01dvj1j2u1dnu14ua3t.png-33.9kB"><br>　　<br>　　关于基于外键的一对一关系，还有一点值得注意，不能在两端都使用外键映射为1-1，例如下面这种情况，表department表和manager都分别设置了外键manager_id和department_id，那么当一条manager记录单向关联了一条department记录，而这条department记录却关联向另一条manager记录，就会出现问题，如下图所示：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/oej3hm94ag370tn82m3zrftt/image_1b372rtct32gnaf1uu216bkcs94a.png" alt="image_1b372rtct32gnaf1uu216bkcs94a.png-92kB">
　　　
　　　</p>
<h2 id="基于主键的一对一关联关系"><a href="#基于主键的一对一关联关系" class="headerlink" title="基于主键的一对一关联关系"></a>基于主键的一对一关联关系</h2><p>　　基于主键的1-1映射策略，是指一端的主键生成器使用foreign策略，表明根据“对方”的主键来生成自己的主键，自己并不能独立生成主键。&lt;param&gt;子节点指定使用当前持久化类的哪一个属性来作为“对方”。例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"foreign"</span>&gt;</span></div><div class="line">            	<span class="comment">&lt;!-- property 属性指定使用当前持久化类的哪一个属性的主键作为外键 --&gt;</span></div><div class="line">            	<span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"property"</span>&gt;</span>mgr<span class="tag">&lt;/<span class="name">param</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">generator</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>　　采用foreign主键生成器策略的一端使用one-to-one元素映射关联属性，需要在one-to-one节点中设置constrained=”true”，以指定为当前持久化类对应的数据库表的主键添加一个外键约束，引用被关联的对象（即“对方”）所对应的数据库表的主键。另一端同样使用one-to-one节点映射关联关系。<br>　　下面我们仍以department和manager的例子进行测试，首先新建两个类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Integer deptId;</div><div class="line">	<span class="keyword">private</span> String deptName;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Manager mgr;</div><div class="line">	</div><div class="line">	<span class="comment">//getters and setters</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Integer mgrId;</div><div class="line">	<span class="keyword">private</span> String mgrName;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Department dept;</div><div class="line">	</div><div class="line">	<span class="comment">//getters and setters</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>映射文件：<br>　<br>Department.hbm.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></div><div class="line">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.atguigu.hibernate.one2one.primary"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Department"</span> <span class="attr">table</span>=<span class="string">"DEPARTMENTS"</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"deptId"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"DEPT_ID"</span> /&gt;</span></div><div class="line">            <span class="comment">&lt;!-- 使用外键的方式来生成当前的主键 --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"foreign"</span>&gt;</span></div><div class="line">            	<span class="comment">&lt;!-- property 属性指定使用当前持久化类的哪一个属性的主键作为外键 --&gt;</span></div><div class="line">            	<span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"property"</span>&gt;</span>mgr<span class="tag">&lt;/<span class="name">param</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">generator</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"deptName"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"DEPT_NAME"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">		</div><div class="line">		<span class="comment">&lt;!--  </span></div><div class="line">		采用 foreign 主键生成器策略的一端增加 one-to-one 元素映射关联属性,</div><div class="line">		其 one-to-one 节点还应增加 constrained=true 属性, 以使当前的主键上添加外键约束</div><div class="line">		--&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"mgr"</span> <span class="attr">class</span>=<span class="string">"Manager"</span> <span class="attr">constrained</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">one-to-one</span>&gt;</span></div><div class="line">					        </div><div class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>Manager.hbm.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></div><div class="line">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.atguigu.hibernate.one2one.primary.Manager"</span> <span class="attr">table</span>=<span class="string">"MANAGERS"</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"mgrId"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"MGR_ID"</span> /&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mgrName"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"MGR_NAME"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"dept"</span> </span></div><div class="line">        	<span class="attr">class</span>=<span class="string">"com.atguigu.hibernate.one2one.primary.Department"</span>&gt;<span class="tag">&lt;/<span class="name">one-to-one</span>&gt;</span></div><div class="line">        </div><div class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></div><div class="line">    </div><div class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>生成的数据库表如下：<br>　<br>managers<br><img src="http://static.zybuluo.com/xiangwanpeng/ivymbusmibiu54s4s1xypq7o/image_1b373jjnq7vj1dck1j6f4qkvjg4n.png" alt="image_1b373jjnq7vj1dck1j6f4qkvjg4n.png-16.2kB"></p>
<p>departments<br><img src="http://static.zybuluo.com/xiangwanpeng/93yr8u63bf0k6x07i2041iol/image_1b373km8b96o52engkc4s197a54.png" alt="image_1b373km8b96o52engkc4s197a54.png-16.9kB"><br><img src="http://static.zybuluo.com/xiangwanpeng/396jnpd1kdoab1xd5nr94fl5/image_1b373l1mp1cm2161gs14amffm5h.png" alt="image_1b373l1mp1cm2161gs14amffm5h.png-17.9kB"><br>可以看到，表departments是根据主键DEPT_ID来关联表managers的。<br>　<br>下面测试save和get方法：</p>
<p><strong>基于主键的1-1关联关系的save操作：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span></span>&#123;</div><div class="line">		</div><div class="line">		Department department = <span class="keyword">new</span> Department();</div><div class="line">		department.setDeptName(<span class="string">"DEPT-AA"</span>);</div><div class="line">		</div><div class="line">		Manager manager = <span class="keyword">new</span> Manager();</div><div class="line">		manager.setMgrName(<span class="string">"MGR-AA"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">//设定关联关系</span></div><div class="line">		manager.setDept(department);</div><div class="line">		department.setMgr(manager);</div><div class="line">		</div><div class="line">		<span class="comment">//保存操作</span></div><div class="line">		<span class="comment">//先插入哪一个都不会有多余的 UPDATE</span></div><div class="line">		session.save(department);</div><div class="line">		session.save(manager);</div><div class="line">		</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>　　和之前不同的是，不论是先执行session.save(department);，还是先执行session.save(manager);，效果都是一样的，都只有两条insert语句，不会有update语句，而且都会先执行insert into managers，后执行insert into departments，如下图：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/60a28iz3ufnqkrg7pl6ra2lv/image_1b374o1mk1nr6pit19rc154h1ais5u.png" alt="image_1b374o1mk1nr6pit19rc154h1ais5u.png-22.1kB"><br>　　<br>　　这是因为，现在department是根据主键关联manager，主键是不能像外键那样先被置为null然后进行update修改的，所以不论哪一个语句放在前面，都会先等到manager记录插入后，再插入department记录。<br>　　<br><strong>基于主键的1-1关联关系的get操作：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGet</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//1. 默认情况下对关联属性使用懒加载</span></div><div class="line">		Department dept = (Department) session.get(Department.class, <span class="number">1</span>);</div><div class="line">		System.out.println(dept.getDeptName()); </div><div class="line">		</div><div class="line">		<span class="comment">//2. 所以会出现懒加载异常的问题. </span></div><div class="line">		Manager mgr = dept.getMgr();</div><div class="line">		System.out.println(mgr.getMgrName()); </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGet2</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//在查询没有外键的实体对象时, 使用的左外连接查询, 一并查询出其关联的对象</span></div><div class="line">		<span class="comment">//并已经进行初始化. </span></div><div class="line">		Manager mgr = (Manager) session.get(Manager.class, <span class="number">1</span>);</div><div class="line">		<span class="comment">/*System.out.println(mgr.getMgrName()); </span></div><div class="line">		System.out.println(mgr.getDept().getDeptName()); */</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>　　基于主键的1-1和基于外键的1-1十分相似，在查询department时都使用懒加载机制，可能会抛出懒加载异常，在查询manager时都会使用左外连接，但不同的是，我们在Manager.hbm.xml文件的one-to-one节点中没有设置property-ref属性，即默认department中关联manager的字段是department的id，这正是我们在基于主键的1-1关系中希望的，所以可以看到，左外连接的连接条件是dept.dept_id = mgr.manager_id：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/r4klndo7jvpmu51k5wf3843b/image_1b376sjn8145n11rm1844dfshjg6r.png" alt="image_1b376sjn8145n11rm1844dfshjg6r.png-39.6kB"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/04/Hibernate的一对多关联关系（单向和双向）/" itemprop="url">
                  Hibernate的一对多关联关系（单向和双向）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-04T20:10:36+08:00" content="2016-12-04">
              2016-12-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hibernate/" itemprop="url" rel="index">
                    <span itemprop="name">Hibernate</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/04/Hibernate的一对多关联关系（单向和双向）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/04/Hibernate的一对多关联关系（单向和双向）/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　在领域模型中，类与类之间最普遍的关系就是关联关系。在 UML 中，关联是有方向的。以 Customer 和 Order 为例：一个用户能发出多个订单, 而一个订单只能属于一个客户。从 Order 到 Customer 的关联是多对一关联; 而从 Customer 到 Order 是一对多关联。
　　</p>
<h2 id="单向n-1的关联关系"><a href="#单向n-1的关联关系" class="headerlink" title="单向n-1的关联关系"></a>单向n-1的关联关系</h2><p>　　单向 n-1 关联只需从 n 的一端可以访问 1 的一端。<br>　　<strong>域模型：</strong>从 Order 到 Customer 的多对一单向关联需要在Order 类中定义一个 Customer 属性，而在 Customer 类中无需定义存放 Order 对象的集合属性。<br>　　<strong>关系数据模型：</strong> ORDERS 表中的 CUSTOMER_ID 参照 CUSTOMER 表的主键。（外键）<br>　　Hibernate 使用 <many-to-one> 元素来映射多对一关联关系。<br>　　例如，在Customer和Order的例子中，首先创建两个类文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Integer customerId;</div><div class="line">	<span class="keyword">private</span> String customerName;</div><div class="line">	</div><div class="line">	<span class="comment">//getters and setters</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Integer orderId;</div><div class="line">	<span class="keyword">private</span> String orderName;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Customer customer;</div><div class="line">	</div><div class="line">	<span class="comment">//getters and setters</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></many-to-one></p>
<p>生成hibernate映射文件：</p>
<p>Customer.hbm.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></div><div class="line">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.atguigu.hibernate.entities.n21.Customer"</span> <span class="attr">table</span>=<span class="string">"CUSTOMERS"</span>&gt;</span></div><div class="line">    </div><div class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"customerId"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"CUSTOMER_ID"</span> /&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">    </div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"customerName"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"CUSTOMER_NAME"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        </div><div class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></div><div class="line">    </div><div class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>Order.hbm.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></div><div class="line">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.atguigu.hibernate.entities.n21"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Order"</span> <span class="attr">table</span>=<span class="string">"ORDERS"</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"orderId"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"ORDER_ID"</span> /&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"orderName"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"ORDER_NAME"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        </div><div class="line">		<span class="comment">&lt;!-- </span></div><div class="line">			映射多对一的关联关系。 使用 many-to-one 来映射多对一的关联关系 </div><div class="line">			name: 多这一端关联的一那一端的属性的名字</div><div class="line">			class: 一那一端的属性对应的类名</div><div class="line">			column: 一那一端在多的一端对应的数据表中的外键的名字</div><div class="line">		--&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"customer"</span> <span class="attr">class</span>=<span class="string">"Customer"</span> <span class="attr">column</span>=<span class="string">"CUSTOMER_ID"</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>先随便运行一个程序，来生成数据库表：<br>　<br>customers表<br><img src="http://static.zybuluo.com/xiangwanpeng/yp2cxzzrglfb6eyuooaaba2p/image_1b34sm9cq1m8p194v1e3p1jdlmnk9.png" alt="image_1b34sm9cq1m8p194v1e3p1jdlmnk9.png-21.3kB"></p>
<p>orders表<br><img src="http://static.zybuluo.com/xiangwanpeng/9n0kmfzp3ch5kkuxw4oplo12/image_1b34sn5651s8a1es8j9e1sar1sm2m.png" alt="image_1b34sn5651s8a1es8j9e1sar1sm2m.png-25.8kB"></p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/ww4a7yb5ppl8hg72y2y6vu05/image_1b34snfoddfq15l2mn2i7r5mr13.png" alt="image_1b34snfoddfq15l2mn2i7r5mr13.png-17.7kB"><br>　<br><strong>单向n-1的save操作：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMany2OneSave</span><span class="params">()</span></span>&#123;</div><div class="line">		Customer customer = <span class="keyword">new</span> Customer();</div><div class="line">		customer.setCustomerName(<span class="string">"AA"</span>);</div><div class="line">		</div><div class="line">		Order order1 = <span class="keyword">new</span> Order();</div><div class="line">		order1.setOrderName(<span class="string">"ORDER-1"</span>);</div><div class="line">		</div><div class="line">		Order order2 = <span class="keyword">new</span> Order();</div><div class="line">		order2.setOrderName(<span class="string">"ORDER-2"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">//设定关联关系</span></div><div class="line">		order1.setCustomer(customer);</div><div class="line">		order2.setCustomer(customer);</div><div class="line">		</div><div class="line">		<span class="comment">//执行  save 操作: 先插入 Customer, 再插入 Order, 3 条 INSERT</span></div><div class="line">		<span class="comment">//先插入 1 的一端, 再插入 n 的一端, 只有 INSERT 语句.</span></div><div class="line">		session.save(customer);</div><div class="line">		</div><div class="line">		session.save(order1);</div><div class="line">		session.save(order2);</div><div class="line">		</div><div class="line">		<span class="comment">//先插入 Order, 再插入 Customer. 3 条 INSERT, 2 条 UPDATE</span></div><div class="line">		<span class="comment">//先插入 n 的一端, 再插入 1 的一端, 会多出 UPDATE 语句!</span></div><div class="line">		<span class="comment">//因为在插入多的一端时, 无法确定 1 的一端的外键值. 所以只能等 1 的一端插入后, 再额外发送 UPDATE 语句.</span></div><div class="line">		<span class="comment">//推荐先插入 1 的一端, 后插入 n 的一端</span></div><div class="line">		<span class="comment">//session.save(order1);</span></div><div class="line">		<span class="comment">//session.save(order2);</span></div><div class="line">		</div><div class="line">		<span class="comment">//session.save(customer);</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行程序，可以成功插入记录，并且在控制台只会打印三条insert语句：</p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/ot3otmy98s9o8luusyjd0pzl/image_1b34t38nn1q6e1lavbqclas1oka1g.png" alt="image_1b34t38nn1q6e1lavbqclas1oka1g.png-11.8kB"></p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/i3copghkmaep4p53mzz4td9u/image_1b34t3h021na01pbno00vp01g4m1t.png" alt="image_1b34t3h021na01pbno00vp01g4m1t.png-11.7kB"></p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/69b3y4gvzeci42mjm195f9zj/image_1b34t4fap1gq41b5in52i8v1vmd2a.png" alt="image_1b34t4fap1gq41b5in52i8v1vmd2a.png-37.4kB"></p>
<p>但是，如果注释掉倒数4，5，6行的代码，而使用最后的三行代码，即先保存order1和order2，再保存customer，同样也可以成功插入，但是除了会输出三行insert语句，还会输出两行update语句。如下图：<br><img src="http://static.zybuluo.com/xiangwanpeng/3i1ti1hre5qdhkri5vm6xmtq/image_1b34tf2baivg10kv1bplc931npu2n.png" alt="image_1b34tf2baivg10kv1bplc931npu2n.png-28.7kB"><br>　<br>这是因为在先插入order记录时，无法确定外键值customer_id，只能先置为null，所以只能等customer记录插入后，再额外发送 UPDATE 语句去更新customer_id。所以，建议先插入1的那一端，即customer，后插入n的这一端，即order。</p>
<p><strong>单向n-1的get操作：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMany2OneGet</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//1. 若查询多的一端的一个对象, 则默认情况下, 只查询了多的一端的对象. 而没有查询关联的 1 的那一端的对象!</span></div><div class="line">		Order order = (Order) session.get(Order.class, <span class="number">1</span>);</div><div class="line">		System.out.println(order.getOrderName()); </div><div class="line">		</div><div class="line">		System.out.println(order.getCustomer().getClass().getName());</div><div class="line">		</div><div class="line">		<span class="comment">//session.close();</span></div><div class="line">		</div><div class="line">		<span class="comment">//2. 只有在需要使用到关联的对象时, 才发送对应的 SQL 语句. </span></div><div class="line">		Customer customer = order.getCustomer();</div><div class="line">		System.out.println(customer.getCustomerName()); </div><div class="line">		<span class="comment">//3. 在查询 Customer 对象时, 由多的一端导航到 1 的一端时, </span></div><div class="line">		<span class="comment">//若此时 session 已被关闭, 则默认情况下</span></div><div class="line">		<span class="comment">//会发生 LazyInitializationException 异常</span></div><div class="line">		</div><div class="line">		<span class="comment">//4. 获取 Order 对象时, 默认情况下, 其关联的 Customer 对象是一个代理对象!</span></div><div class="line">		</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>在n-1的get操作中，使用了懒加载机制。如果查询的是order对象，则默认情况下不会立即查找对应的customer对象，而只有等到需要使用这个customer对象时，才会发送select语句查询该customer对象。那么当然，如果在使用该对象之前，session被关闭了，也会抛出懒加载异常。</p>
<p><strong>单向n-1的update操作：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</div><div class="line">		Order order = (Order) session.get(Order.class, <span class="number">1</span>);</div><div class="line">		order.getCustomer().setCustomerName(<span class="string">"AAA"</span>);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><strong>单向n-1的delete操作：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//在不设定级联关系的情况下, 且 1 这一端的对象有 n 的对象在引用, 不能直接删除 1 这一端的对象</span></div><div class="line">		Customer customer = (Customer) session.get(Customer.class, <span class="number">1</span>);</div><div class="line">		session.delete(customer); </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>在不设定级联关系的情况下，且 1 这一端的对象有 n 的对象在引用，则不能直接删除 1 这一端的对象。我们可以在customer映射文件的set节点中设置级联属性为级联删除，就可以直接删除1这一端的对象：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"orders"</span> <span class="attr">table</span>=<span class="string">"ORDERS"</span> <span class="attr">cascade</span>=<span class="string">"delete"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>除了级联删除之外，还有其他的级联属性，如下图所示：<br><img src="http://static.zybuluo.com/xiangwanpeng/22ncw1f6kv5l7w7tfuy980o0/image_1b352uke6ftd1kj45n93jejci4o.png" alt="image_1b352uke6ftd1kj45n93jejci4o.png-217.9kB"></p>
<p>但是在开发时并不建议设定级联属性，而建议使用手工的方式来处理。
　</p>
<h2 id="双向1-n的关联关系"><a href="#双向1-n的关联关系" class="headerlink" title="双向1-n的关联关系"></a>双向1-n的关联关系</h2><p>　　双向 1-n 与双向 n-1 是完全相同的两种情形。<br>　　双向 1-n 需要在1的一端可以访问n的一端,反之亦然。<br>　　<strong>域模型:</strong>从Order到Customer的多对一双向关联需要在Order类中定义一个Customer属性,而在Customer类中需定义存放Order对象的集合属性。<br>　　<strong>关系数据模型:</strong> ORDERS表中的CUSTOMER_ID参照CUSTOMER表的主键。（外键）<br>　　<br>几个注意点：</p>
<ol>
<li>当 Session从数据库中加载Java集合时，创建的是Hibernate内置集合类的实例，因此在持久化类中定义集合属性时必须把属性声明为Java 接口类型，例如应该声明为Set而不是HashSet。Hibernate 的内置集合类具有集合代理功能，支持延迟检索策略。类似于在单向n-1关系的get操作，如果在双向1-n的get操作中获取了customer对象，如果不使用它存放order的集合，那么这个集合就不会被加载，只有使用到时才会加载。</li>
<li><p>在customer类中定义集合属性时，通常把它初始化为集合实现类的一个实例，这样可以提高程序的健壮性，避免应用程序访问取值为null的集合的方法抛出NullPointerException。</p>
<p>Hibernate 使用 <set>元素来映射set类型的属性。下面我们仍以customer和order的例子来测试，首先创建两个类：</set></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Integer customerId;</div><div class="line">	<span class="keyword">private</span> String customerName;</div><div class="line">	</div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 1. 声明集合类型时, 需使用接口类型, 因为 hibernate 在获取</div><div class="line">	 * 集合类型时, 返回的是 Hibernate 内置的集合类型, 而不是 JavaSE 一个标准的集合实现. </div><div class="line">	 * 2. 需要把集合进行初始化, 可以防止发生空指针异常</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="comment">//getters and setters</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Integer orderId;</div><div class="line">	<span class="keyword">private</span> String orderName;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Customer customer;</div><div class="line">	</div><div class="line">	<span class="comment">//getters and setters</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>生成Hibernate映射文件：</p>
<p>Order.hbm.xml（和单向n-1相同）<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></div><div class="line">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.atguigu.hibernate.entities.n21.both"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Order"</span> <span class="attr">table</span>=<span class="string">"ORDERS"</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"orderId"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"ORDER_ID"</span> /&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"orderName"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"ORDER_NAME"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        </div><div class="line">		<span class="comment">&lt;!-- </span></div><div class="line">			映射多对一的关联关系。 使用 many-to-one 来映射多对一的关联关系 </div><div class="line">			name: 多这一端关联的一那一端的属性的名字</div><div class="line">			class: 一那一端的属性对应的类名</div><div class="line">			column: 一那一端在多的一端对应的数据表中的外键的名字</div><div class="line">		--&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"customer"</span> <span class="attr">class</span>=<span class="string">"Customer"</span> <span class="attr">column</span>=<span class="string">"CUSTOMER_ID"</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>Customer.hbm.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></div><div class="line">"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.atguigu.hibernate.entities.n21.both"</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Customer"</span> <span class="attr">table</span>=<span class="string">"CUSTOMERS"</span>&gt;</span></div><div class="line">    </div><div class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"customerId"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"CUSTOMER_ID"</span> /&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">    </div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"customerName"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"CUSTOMER_NAME"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="comment">&lt;!-- 映射 1 对多的那个集合属性 --&gt;</span></div><div class="line">        <span class="comment">&lt;!-- set: 映射 set 类型的属性, name:一的这一端关联的多的那一端的属性名,table: set 中的元素对应的记录放在哪一个数据表中. 该值需要和多对一的多的那个表的名字一致 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"orders"</span> <span class="attr">table</span>=<span class="string">"ORDERS"</span>&gt;</span></div><div class="line">        	<span class="comment">&lt;!-- 指定关联的表中的外键列的名字 --&gt;</span></div><div class="line">        	<span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"CUSTOMER_ID"</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></div><div class="line">        	<span class="comment">&lt;!-- 指定映射类型 --&gt;</span></div><div class="line">        	<span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"Order"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">        </div><div class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></div><div class="line">    </div><div class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>生成的数据库表的结构和单向n-1中相同，现在来测试各种方法：</p>
<p><strong>双向1-n的save操作：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOne2ManySave</span><span class="params">()</span></span>&#123;</div><div class="line">		Customer customer = <span class="keyword">new</span> Customer();</div><div class="line">		customer.setCustomerName(<span class="string">"AA"</span>);</div><div class="line">		</div><div class="line">		Order order1 = <span class="keyword">new</span> Order();</div><div class="line">		order1.setOrderName(<span class="string">"ORDER-1"</span>);</div><div class="line">		</div><div class="line">		Order order2 = <span class="keyword">new</span> Order();</div><div class="line">		order2.setOrderName(<span class="string">"ORDER-2"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">//设定关联关系</span></div><div class="line">		order1.setCustomer(customer);</div><div class="line">		order2.setCustomer(customer);</div><div class="line">		</div><div class="line">		customer.getOrders().add(order1);</div><div class="line">		customer.getOrders().add(order2);</div><div class="line">		</div><div class="line">		<span class="comment">//执行  save 操作: 先插入 Customer, 再插入 Order, 3 条 INSERT, 2 条 UPDATE</span></div><div class="line">		<span class="comment">//因为 1 的一端和 n 的一端都维护关联关系. 所以会多出 UPDATE</span></div><div class="line">		<span class="comment">//可以在 1 的一端的 set 节点指定 inverse=true, 来使 1 的一端放弃维护关联关系!</span></div><div class="line">		<span class="comment">//建议设定 set 的 inverse=true, 建议先插入 1 的一端, 后插入多的一端</span></div><div class="line">		<span class="comment">//好处是不会多出 UPDATE 语句</span></div><div class="line">		session.save(customer);</div><div class="line">		</div><div class="line">		session.save(order1);</div><div class="line">		session.save(order2);</div><div class="line">		</div><div class="line">		<span class="comment">//先插入 Order, 再插入 Cusomer, 3 条 INSERT, 4 条 UPDATE</span></div><div class="line">		<span class="comment">//session.save(order1);</span></div><div class="line">		<span class="comment">//session.save(order2);</span></div><div class="line">		</div><div class="line">		<span class="comment">//session.save(customer);</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当我们使用倒数第4，5，6行代码进行插入，即先保存customer，再保存order1和order2，这不同于单向n-1中的操作，虽然插入都是成功的，但是此处除了会打印三条insert语句，还会打印两条update语句：<br><img src="http://static.zybuluo.com/xiangwanpeng/juefw7x1aqms4xnczrb8v7bf/image_1b3509k521lab126n1k8fmk5v5934.png" alt="image_1b3509k521lab126n1k8fmk5v5934.png-26.1kB"></p>
<p>这是因为， 由于是双向的关联关系，所以 1 的一端和 n 的一端都需要维护关联关系。当先插入customer对象后，customer中的set集合里面的order的id也还未知，会先被置为null，所以当order1和order2被插入后，会多出两条update语句。那么可以推测出，如果注释掉倒数第4，5，6行代码，而执行最后三行代码，那么除了有三条insert语句，还会打印出4条update语句，因为order1和order2先各维护一次，customer会再维护两次。如下图：</p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/420934o0zv40u0u9z90v9d0p/image_1b350gg27r8e1foo45umhn1khs3h.png" alt="image_1b350gg27r8e1foo45umhn1khs3h.png-30kB"></p>
<p>　　那么，如果我们不希望两端都维护关联关系，该怎么办呢？<br>　　解决办法是，在hibernate的配置文件中可以通过设置inverse属性来决定是由双向关联的哪一方来维护表和表之间的关系。inverse = false的为主动方，inverse = true 的为被动方。由主动方负责维护关 联关系。在没有设置inverse属性的情况下，默认父子两边都维护父子关系。<br>　　在双向 1-n 关系中，将 n 方设为主控方将有助于性能改善，而如果将 1 方设为主控方会额外多出update语句。这好比如果要国家元首记住全国人民的名字不太现实，但要让全国人民知道国家元首，就容易得多。<br>　　例如，现在我们在Customer.hbm.xml映射文件中设置set节点为：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"orders"</span> <span class="attr">table</span>=<span class="string">"ORDERS"</span> <span class="attr">inverse</span>=<span class="string">"true"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后在test方法中先插入customer，再插入order1和order2，则只会打印三条insert语句，而不会打印update语句：</p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/bbq6j8lirhwm7x2xjwqoovpi/image_1b3510fhr1i82j7n1krfi6ufcf3u.png" alt="image_1b3510fhr1i82j7n1krfi6ufcf3u.png-32.6kB"></p>
<p><strong>双向1-n的get操作：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOne2ManyGet</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//1. 对 n 的一端的集合使用延迟加载</span></div><div class="line">		Customer customer = (Customer) session.get(Customer.class, <span class="number">7</span>);</div><div class="line">		System.out.println(customer.getCustomerName()); </div><div class="line">		<span class="comment">//2. 返回的多的一端的集合时 Hibernate 内置的集合类型. </span></div><div class="line">		<span class="comment">//该类型具有延迟加载和存放代理对象的功能. </span></div><div class="line">		System.out.println(customer.getOrders().getClass()); </div><div class="line">		</div><div class="line">		<span class="comment">//session.close();</span></div><div class="line">		<span class="comment">//3. 可能会抛出 LazyInitializationException 异常 </span></div><div class="line">		</div><div class="line">		System.out.println(customer.getOrders().size()); </div><div class="line">		</div><div class="line">		<span class="comment">//4. 再需要使用集合中元素的时候进行初始化. </span></div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>　　与单向n-1的get操作类似，在双向1-n的get操作中，如果先加载了customer对象，在使用它的orders集合之前，是不会加载orders集合的，这使用了懒加载机制，那么同样，也有可能抛出懒加载异常。<br>　　<br>　　<br><strong>双向1-n的update操作：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdat2</span><span class="params">()</span></span>&#123;</div><div class="line">		Customer customer = (Customer) session.get(Customer.class, <span class="number">1</span>);</div><div class="line">		customer.getOrders().iterator().next().setOrderName(<span class="string">"GGG"</span>); </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>可以通过1这一端的customer来更新n那一端的order。<br>　<br><strong>双向1-n的delete操作：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//在不设定级联关系的情况下, 且 1 这一端的对象有 n 的对象在引用, 不能直接删除 1 这一端的对象</span></div><div class="line">		Customer customer = (Customer) session.get(Customer.class, <span class="number">1</span>);</div><div class="line">		session.delete(customer); </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>同单向n-1中一样，在不设定级联关系的情况下，且 1 这一端的对象有 n 的对象在引用，则不能直接删除 1 这一端的对象。<br>　<br>　<br>　　此外，我们还可以在customer映射文件的set节点中设置order-by属性， 在查询时对集合中的元素进行排序，order-by 中使用的是表的字段名， 而不是持久化类的属性名。例如，对orders集合根据orderName进行降序排列：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"orders"</span> <span class="attr">table</span>=<span class="string">"ORDERS"</span> <span class="attr">order-by</span>=<span class="string">"ORDER_NAME DESC"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>　　最后补充一下，关于双向1-n的两个类的映射文件中，属性的对应关系，如下图所示：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/s40rysetw1jqovp4xuec6fij/image_1b3523tsj1ueu10p2bu7n031bms4b.png" alt="image_1b3523tsj1ueu10p2bu7n031bms4b.png-177.1kB"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/04/Hibernate映射组成关系/" itemprop="url">
                  Hibernate映射组成关系
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-04T15:40:07+08:00" content="2016-12-04">
              2016-12-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hibernate/" itemprop="url" rel="index">
                    <span itemprop="name">Hibernate</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/04/Hibernate映射组成关系/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/04/Hibernate映射组成关系/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　建立域模型和关系数据模型有着不同的出发点。<br>　　域模型（面向对象设计）:由程序代码组成，通过细化持久化类的的粒度可提高代码的可重用性，简化编程。<br>　　关系数据模型（数据库设计）：在没有数据冗余的情况下，应该尽可能减少表的数目，简化表之间的参照关系，以便提高数据的访问速度。<br>　　<br>　　在这篇文章中我们以Worker（工人）和Pay（薪酬）之间的关系为例进行说明：<br>　　<img src="http://static.zybuluo.com/xiangwanpeng/wtnzb9aa5ds6edeg1rbujv0u/image_1b34cojeh1ua6193h6cg128t9fc9.png" alt="image_1b34cojeh1ua6193h6cg128t9fc9.png-37.2kB"><br>　　<br>　　Hibernate 把持久化类的属性分为两种:<br>　　<strong>值(value)类型：</strong>没有OID，不能被单独持久化，生命周期依赖于所属的持久化类的对象的生命周期。<br>　　<strong>实体(entity)类型：</strong>有OID，可以被单独持久化，有独立的生命周期。<br>　　<br>　　显然在上述例子中Worker为实体类型，Pay为值类型。如果我们将这两个类根据组成关系映射为数据库中的一张表而不是两张表，那么单表查询的速度是要快于多表查询的。<br>　　Hibernate 使用 &lt;component&gt; 元素来映射组成关系, 该元素表明 pay 属性是 Worker 类一个组成部分, 在 Hibernate 中称之为组件。<br>　　<br>　　下面进行测试，首先新建两个java类：<br>　　<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Integer id;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Pay pay;</div><div class="line"></div><div class="line">　　<span class="comment">//getters and setters</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pay</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> monthlyPay;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> yearPay;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> vocationWithPay;</div><div class="line">	</div><div class="line">	<span class="comment">//getters and setters</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生成映射文件Worker.hbm.xml，并在映射文件中映射组成关系：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 映射组成关系 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">"pay"</span> <span class="attr">class</span>=<span class="string">"Pay"</span>&gt;</span></div><div class="line">        	<span class="tag">&lt;<span class="name">parent</span> <span class="attr">name</span>=<span class="string">"worker"</span>/&gt;</span></div><div class="line">        	<span class="comment">&lt;!-- 指定组成关系的组件的属性 --&gt;</span></div><div class="line">        	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"monthlyPay"</span> <span class="attr">column</span>=<span class="string">"MONTHLY_PAY"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"yearPay"</span> <span class="attr">column</span>=<span class="string">"YEAR_PAY"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"vocationWithPay"</span> <span class="attr">column</span>=<span class="string">"VOCATION_WITH_PAY"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">component</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>编写测试程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testComponent</span><span class="params">()</span></span>&#123;</div><div class="line">		Worker worker = <span class="keyword">new</span> Worker();</div><div class="line">		Pay pay = <span class="keyword">new</span> Pay();</div><div class="line">		</div><div class="line">		pay.setMonthlyPay(<span class="number">1000</span>);</div><div class="line">		pay.setYearPay(<span class="number">80000</span>); </div><div class="line">		pay.setVocationWithPay(<span class="number">5</span>);</div><div class="line">		</div><div class="line">		worker.setName(<span class="string">"ABCD"</span>);</div><div class="line">		worker.setPay(pay);</div><div class="line">		</div><div class="line">		session.save(worker);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>运行程序，发现生成了一张数据表worker：</p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/oxzov30sotvxboalu8uvu264/image_1b34ddp4h2vf1b6p1p7ji341u32m.png" alt="image_1b34ddp4h2vf1b6p1p7ji341u32m.png-20.1kB"></p>
<p>并且成功插入了记录：</p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/6m6xfxj1gm5r1cha4uye4z3x/image_1b34dfjo817uu1rg55kf37e1a3o13.png" alt="image_1b34dfjo817uu1rg55kf37e1a3o13.png-11.6kB"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/04/Java时间和日期类型的Hibernate映射/" itemprop="url">
                  Java时间和日期类型的Hibernate映射
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-04T15:05:24+08:00" content="2016-12-04">
              2016-12-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hibernate/" itemprop="url" rel="index">
                    <span itemprop="name">Hibernate</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/04/Java时间和日期类型的Hibernate映射/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/04/Java时间和日期类型的Hibernate映射/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　在Java中，代表时间和日期的类型包括：java.util.Date和java.util.Calendar。此外在JDBC API中还提供了3个扩展了java.util.Date类的子类：java.sql.Date，java.sql.Time和java.sql.Timestamp，这三个类分别和标准SQL类型中的 DATE，TIME和TIMESTAMP类型对应。<br>　　在标准SQL中，DATE类型表示日期，TIME 类型表示时间，TIMESTAMP 类型表示时间戳，同时包含日期和时间信息。<br>　　<br>　　通常的映射方法为：<br>　　<br>　　因为java.util.Date是java.sql.Date，java.sql.Time和java.sql.Timestamp的父类，所以java.util.Date可以对应标准SQL类型中的DATE，TIME和TIMESTAMP。所以通常<strong>在持久化类中</strong>将时间日期类型<strong>设置为java.util.Date</strong>。<br>　　然后通过Hibernate映射文件的property节点的type属性进行映射，例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"date"</span> <span class="attr">type</span>=<span class="string">"timestamp"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"DATE"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"date"</span> <span class="attr">type</span>=<span class="string">"date"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"DATE"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"date"</span> <span class="attr">type</span>=<span class="string">"time"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"DATE"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>其中 timestamp，date，time 既不是 Java 类型，也不是标准 SQL 类型，而是Hibernate映射类型。关于Hibernate映射类型，我们在介绍映射文件的时候提到过，它是连接Java类型和SQL类型的桥梁，三者之间的关系如下：</p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/09ahhwbvuy1nwbzajoa24o25/image_1b34b3km1m701abc1cq8bfqjlv9.png" alt="image_1b34b3km1m701abc1cq8bfqjlv9.png-153kB"><br><img src="http://static.zybuluo.com/xiangwanpeng/vkoh34sohk9e4fjrhhk8b7mf/image_1b34b4l8n1mstuf088pc261qpem.png" alt="image_1b34b4l8n1mstuf088pc261qpem.png-94.2kB"></p>
<p>现在测试一下，首先在News.java中指定字段Date为java.util.Date类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Date date;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> date;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Date date)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.date = date;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>然后在映射文件中映射为time类型：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"date"</span> <span class="attr">type</span>=<span class="string">"time"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"DATE"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>编写测试程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPropertyUpdate</span><span class="params">()</span></span>&#123;</div><div class="line">		News news = (News) session.get(News.class, <span class="number">1</span>);</div><div class="line">		</div><div class="line">		System.out.println(news);</div><div class="line">		System.out.println(news.getDate().getClass()); </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>运行程序，发现生成的news表中的DATE确实为time类型：</p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/qnpp2z61niiabiv9af398656/image_1b34bhn1e11a61s5m17ac18701kfj13.png" alt="image_1b34bhn1e11a61s5m17ac18701kfj13.png-15.5kB"></p>
<p>并且在控制台输出了java类型为java.sql.Time：</p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/cj0rafewkb3053fsucfx0q98/image_1b34bl66u14b81frmuqmtv1fqn1g.png" alt="image_1b34bl66u14b81frmuqmtv1fqn1g.png-22.8kB"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/04/Hibernate映射文件/" itemprop="url">
                  Hibernate映射文件
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-04T13:27:36+08:00" content="2016-12-04">
              2016-12-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hibernate/" itemprop="url" rel="index">
                    <span itemprop="name">Hibernate</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/04/Hibernate映射文件/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/04/Hibernate映射文件/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="POJO-类和数据库的映射文件-hbm-xml"><a href="#POJO-类和数据库的映射文件-hbm-xml" class="headerlink" title="POJO 类和数据库的映射文件*.hbm.xml"></a>POJO 类和数据库的映射文件*.hbm.xml</h2><p>　　POJO类和关系数据库之间的映射可以用一个XML文档来定义。<br>　　通过POJO类的数据库映射文件，Hibernate可以理解持久化类和数据表之间的对应关系，也可以理解持久化类属性与数据库表列之间的对应关系。在运行时 Hibernate 将根据这个映射文件来生成各种SQL语句，映射文件的扩展名为 .hbm.xml。</p>
<h2 id="映射文件说明"><a href="#映射文件说明" class="headerlink" title="映射文件说明"></a>映射文件说明</h2><ul>
<li>hibernate-mapping<ul>
<li>类层次：class<br>-主键：id<br>-基本类型:property<br>-实体引用类: many-to-one  |  one-to-one<br>-集合:set | list | map | array<br>　one-to-many<br>　many-to-many<br>-子类:subclass | joined-subclass<br>-其它:component | any 等
　</li>
<li>查询语句:query（用来放置查询语句，便于对数据库查询的统一管理和优化）
　</li>
</ul>
</li>
</ul>
<p>下面对各个节点进行介绍</p>
<p><strong>hibernate-mapping</strong><br><img src="http://static.zybuluo.com/xiangwanpeng/jyw6iu3rugw2xeefm5ixe1pn/image_1b346btk31o238fa1j1u1j61n049.png" alt="image_1b346btk31o238fa1j1u1j61n049.png-84.1kB"><br>　<br><strong>class</strong><br><img src="http://static.zybuluo.com/xiangwanpeng/2xg4ijtfoapq14lo5xossvtc/image_1b346dve91mo81m0d17un1uhvcrpm.png" alt="image_1b346dve91mo81m0d17un1uhvcrpm.png-87.6kB"><br>　<br>　<br>在介绍下面的节点之前先来介绍一下<strong>映射对象标识符</strong>：</p>
<ul>
<li>Hibernate使用对象标识符(OID)来建立内存中的对象和数据库表中记录的对应关系，对象的OID和数据表的主键对应，Hibernate通过标识符生成器来为主键赋值。</li>
<li>Hibernate 推荐在数据表中使用代理主键，即不具备业务含义的字段，代理主键通常为整数类型，因为整数类型比字符串类型要节省更多的数据库空间。</li>
<li>在对象-关系映射文件中， &lt;id&gt;元素用来设置对象标识符. &lt;generator&gt;子元素用来设定标识符生成器。</li>
<li>Hibernate提供了标识符生成器接口：IdentifierGenerator，并提供了各种内置实现。<br>　<br><strong>id</strong><br><img src="http://static.zybuluo.com/xiangwanpeng/fuubabhwvogmriv4yaj6v1hz/image_1b346frg8kpu1uui1vcf16961fk313.png" alt="image_1b346frg8kpu1uui1vcf16961fk313.png-51.2kB"><br>　<br><strong>generator</strong><br><img src="http://static.zybuluo.com/xiangwanpeng/wevodqbnrsq5hti2apkrkrio/image_1b346ha6bv66hht1vk9bku10fa1g.png" alt="image_1b346ha6bv66hht1vk9bku10fa1g.png-8.4kB"><br>　<br>下面是hibernate提供的内置标识符生成器：<br><img src="http://static.zybuluo.com/xiangwanpeng/sb1rzrkolgog947coiwcx3wj/image_1b346u22q660j8g1igs1mt81k1n2n.png" alt="image_1b346u22q660j8g1igs1mt81k1n2n.png-63.5kB">
　</li>
<li><p>increment 标识符生成器<br>increment标识符生成器由Hibernate以递增的方式为代理主键赋值，Hibernate会先读取NEWS表中的主键的最大值，而接下来向NEWS表中插入记录时，就在max(id)的基础上递增，增量为 1。<br>适用范围:<br>　　由于increment生存标识符机制不依赖于底层数据库系统，因此它适合所有的数据库系统。<br>　　适用于只有单个Hibernate应用进程访问同一个数据库的场合， 在集群环境下不推荐使用它。（并发问题）<br>　　OID必须为long，int或short类型，如果把OID定义为byte类型，在运行时会抛出异常 。</p>
</li>
<li><p>identity 标识符生成器<br>identity标识符生成器由底层数据库来负责生成标识符，它要求底层数据库把主键定义为自动增长字段类型。<br>适用范围：<br>　　由于identity生成标识符的机制依赖于底层数据库系统，因为要求底层数据库系统必须支持自动正常字段类型，这样的数据库包括：DB2，Mysql，MSSQLServer，Sybase等，不包括oracle。<br>　　OID必须为long，int或short类型，如果把OID定义为byte类型，在运行时会抛出异常。</p>
</li>
<li><p>sequence 标识符生成器<br>sequence标识符生成器利用底层数据库提供的序列来生成标识符。<br>Hibernate在持久化一个News对象时，先从底层数据库的news_seq序列中获得一个唯一的标识号，再把它作为主键值 。<br>适用范围:<br>　　由于sequence生成标识符的机制依赖于底层数据库系统的序列，因此， 要求底层数据库系统必须支持序列。支持序列的数据库包括: DB2， Oracle 等，不包括Mysql。<br>　　OID必须为long，int或short类型，如果把OID定义为byte类型，在运行时会抛出异常。</p>
</li>
<li><p>hilo 标识符生成器<br>hilo标识符生成器由Hibernate按照一种“high/low”算法生成标识符。<br>Hibernate在持久化一个News对象时，由Hibernate负责生成主键值。hilo 标识符生成器在生成标识符时，需要<strong>读取并修改</strong>HI_TABLE表中的NEXT_VALUE值。<br>适用范围:<br>　　由于hilo生存标识符机制不依赖于底层数据库系统，因此它适合所有的数据库系统。<br>　　OID必须为long，int或short类型，如果把OID定义为byte类型，在运行时会抛出异常。</p>
</li>
<li><p>native 标识符生成器 （通常使用的方式）<br>native标识符生成器依据底层数据库对自动生成标识符的支持能力，来选择使用identity，sequence或hilo标识符生成器。<br>适用范围:<br>　　由于native能根据底层数据库系统的类型，自动选择合适的标识符生成器，因此很适合于跨数据库平台开发。<br>　　OID必须为long，int或short类型，如果把OID定义为byte类型，在运行时会抛出异常。<br>　<br><strong>property</strong><br><img src="http://static.zybuluo.com/xiangwanpeng/d5l3y44josx13lb90tjo79gt/image_1b348es521kk81fev41b1q5m38j34.png" alt="image_1b348es521kk81fev41b1q5m38j34.png-205.5kB"><br><img src="http://static.zybuluo.com/xiangwanpeng/d8fcnhuh7hu81nq7agjynn5b/image_1b348ggd013651lsckqg1ptc1sa03h.png" alt="image_1b348ggd013651lsckqg1ptc1sa03h.png-130.5kB"></p>
</li>
<li><p>派生属性：<br>并不是持久化类的所有属性都直接和表的字段匹配，持久化类的有些属性的值必须在运行时通过计算才能得到，这种属性称为派生属性，下面我们使用property的formular属性来测试派生属性：<br>首先在News.java中添加一个desc字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//该属性值为： title：author</span></div><div class="line">	<span class="keyword">private</span> String desc;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> desc;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.desc = desc;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>然后在News的映射文件中映射派生属性：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 映射派生属性 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"desc"</span> <span class="attr">formula</span>=<span class="string">"(SELECT concat(author, ': ', title) FROM NEWS n WHERE n.id = id)"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFormula</span><span class="params">()</span></span>&#123;</div><div class="line">		News news = (News) session.get(News.class, <span class="number">1</span>);</div><div class="line">		</div><div class="line">		System.out.println(news.getDesc());</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<p><img src="http://static.zybuluo.com/xiangwanpeng/i2ujp498ug98t9ac3l3fhxty/image_1b34a68661rcq12o4ms3147m1rae3u.png" alt="image_1b34a68661rcq12o4ms3147m1rae3u.png-66.5kB"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/image/avatar.png"
               alt="Alan" />
          <p class="site-author-name" itemprop="name">Alan</p>
          <p class="site-description motion-element" itemprop="description">Better late than never.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">61</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">74</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xiangwanpeng" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/2810288024/home" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alan</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/VEN/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/VEN/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/VEN/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/VEN/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/VEN/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/VEN/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"xiangwanpeng"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/VEN/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
